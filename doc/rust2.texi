\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename rust.info
@settitle Rust Documentation
@setchapternewpage odd
@c %**end of header

@syncodeindex fn cp

@ifinfo
This manual is for the ``Rust'' programming language.

Copyright 2006-2009 Graydon Hoare

All rights reserved

Licensed to the public under the terms of the GNU GPL (>= 2.0).
See the file COPYING for details
@end ifinfo

@dircategory Programming
@direntry
* rust: (rust).         Rust programming language
@end direntry

@titlepage
@title Rust
@subtitle A general-purpose programming language
@author Graydon Hoare

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2006-2009 Graydon Hoare
All rights reserved
Licensed to the public under the terms of the GNU GPL (>= 3.0).
See the file COPYING for details
@end titlepage

@ifnottex
@node Top
@top Top

Rust Documentation

Rust is a general-purpose programming language. It supports imperative
procedural, concurrent actor and pure functional styles. Rust also
supports generic programming and metaprogramming, in both static and
dynamic styles.

@end ifnottex

@menu
* Introduction::               Background, intentions, relationships to other languages
* Tutorial::                   Gentle introduction to reading Rust code
* Reference::                  Systematic reference of language elements
@end menu

@ifnottex
Complete table of contents
@end ifnottex

@contents

@c ############################################################
@c introduction
@c ############################################################

@node    Introduction
@chapter Introduction

@quotation
  We have to fight chaos, and the most effective way of doing that is
  to prevent its emergence.
@flushright
                                   - Edsger Dijkstra
@end flushright
@end quotation
@sp
@sp

Rust is a ``curly-brace'' block-structured statement language. It
visually resembles the Algol / C family, but differs significantly in
syntactic and semantic details.

@node    Goals
@section Goals

The language design pursues the following goals:

@sp
@itemize
@item Compile-time error detection and prevention.
@item Run-time error isolation and containment.
@item Internet-scale system construction.
@item Loose coupling.
@item System analysis and maintainance affordances.
@item Clarity and precision of expression.
@item Implementation simplicity.
@item Run-time efficiency.
@end itemize
@sp

Note that most of these goals are @emph{engineering} goals, not showcases
for sophisticated language technology. Most of the technology in rust is
@emph{old} and has been seen decades earlier in other languages.

Also note that ``terseness'' and ``expressiveness'' are absent from
the list. Rust programs are often larger and more verbose than
equivalent programs in other languages. The syntax avoids gratuitous
chatter where possible, and keywords are kept short and punchy, but
Rust is unlikely to win any competitions for ``shortest program to
accomplish a given task''. The most understandable and maintainable
program is not usually the shortest.

@page
@node    Sales Pitch
@section Sales Pitch

The following comprises a brief ``sales pitch'' overview of the
salient features of Rust, relative to other languages.

@itemize

@item Predictalbe native code, simple runtime

The meaning and cost of every operation within a Rust program is
intended to be easy to model for the reader. The code should not
``surprise'' the programmer once it has been compiled.

Rust is designed to be compiled to mostly-static native code, with
relatively large compilation units and plenty of room for whole-unit
optimisation. The output of a Rust compilation is a standard loadable
object of machine code (ELF, PE, Mach-O), containing standard metadata
(DWARF), and works with existing disassemblers, analysis tools,
debuggers and profilers. Such object files can be dynamically loaded,
via the standard operating-system loader, into other processes, and
executed cooperatively.

The Rust runtime is relatively small and provides some memory
management, lightweight process scheduling, internal communication
buffering and reflection services, but these are all implemented in a
straightforward and obvious fashion, in standard C, with a low-level
service provider interface available to embeddings. No research-level
virtual machine, JIT or garbage collection technology is required.

@item Integrated system-construction facility

The units of compilation of Rust are multi-file amalgamations called
@emph{crates}. A crate is described by a separate, declarative type of
source file that guides both the compilation of the crate, its
packaging, its versioning, and its external dependencies. Crates are
also the units of distribution and loading. Significantly: the
dependency graph of crates is @emph{acyclic} and @emph{anonymous}:
there is no global namespace for crates, and module-level recursion
cannot cross crate barriers.

Unlike many languages, individual modules do @emph{not} carry all the
mechanisms or restrictions of crates. Modules and crates serve
different roles.

@item Lightweight cooperative processes

Like many @emph{actor} languages, Rust provides an isolation (and
concurrency) model based on lightweight processes scheduled by the
language runtime. These processes are inexpensive and @emph{mostly}
statically secure from one another; breaking the rule of process
isolation is only possible by calling external (C) code.

Inter-process communication is single-duplex, based on ports and
channels. Communication can be buffered or unbuffered: an unbuffered
send is modeled as a buffered send followed by a synchronous buffer
flush. Communication is fair and randomised on the receiver side.

@item Stack-based iterator functions

Between the extremes of ``asynchronous concurrent processes'' and
``synchronous single-invocation functions'', Rust also supports a form
of multiple-invocation iterator function, modeled after the same
facility in @code{CLU}. Iterator functions can @emph{temporarily}
suspend execution and return a value to their caller, resuming
execution at the point of suspension when they are re-invoked.

The iterator function facility is tightly integrated into the
@code{for} loop construct. Only loop headers can invoke iterator
functions, and iterator frames live on the same call stack as normal
function frames, so cannot escape the invoking loop.

@item Direct interface to C code

Rust can load and call many C library functions simply by declaring
them in the enclosing crate file. Calling a C function statically
marks a process as ``unsafe'', unless the unsafe process is further
isolated within an external ``heavyweight'' operating-system
subprocess. Every ``unsafe'' process in a Rust compilation unit must
be explicitly marked as audited and authorised in the crate file.

@item Typestate system

Every storage slot in Rust participates in not only a conventional
structural static type system, describing the interpretation of memory
in the slot, but also a @emph{typestate} system. The static typestates
of a program describe the set of @emph{pure, dynamic predicates} that
provably hold over some set of slots, at various points in the
program's runtime. The static calculation of the typestates of a
program is a dataflow problem, and handles user-defined predicates in
a similar fashion to the way the type system permits user-defined
types.

A short way of thinking of this is: types statically model the kinds
of values held in slots, typestates statically model @emph{assertions
that hold} before and after statements.

@item Safe control over memory allocation, packing and aliasing.

Every variable or field in Rust is a combination of a type and a mode;
this combination is called a @emph{slot}. There are 4 kinds of slot
mode, denoting 4 ways of referring to a value:

@itemize
@item ``interior'' (by value)
@item ``exterior'' (by reference-counted heap allocation)
@item ``read-alias'' (by provably-owned direct address)
@item ``write-alias'' (as with read-alias, but permitting writes)
@end itemize

Interior slots declared as variables in a function are allocated very
quickly on the stack, as part of a local activation frame, as in C or
C++. Read-alias slots permit efficient by-reference parameter passing
without adjusting heap reference counts, as alias lifetimes outlive
callee lifetimes. Write-alias slots additionally permit controlled
mutation of a parameter by a callee, effectively providing ``out
parameters''.

Copying data between slots of different modes may cause either a
simple address assignment or reference-count adjustment, or may cause
a value to be ``transplanted'': copied by value from the interior of
one memory structure to another, or between stack and
heap. Transplanting, when necessary, is predictable and automatic, as
part of the definition of the assignment operator (=).

In addition, slots have a static initialisation state that is
calculated by the typestate system. This permits late initialisation
of variables in functions with complex control-flow, while still
guaranteeing that every use of a slot occurs after it has been
initialised.

@item Acyclic ownership graph, copy-on-write memory semantics.

Three of the four slot modes in Rust are mutable, but writing through
a slot requires that the writer is the sole owner of the memory
structure being written to. When a structure is shared by an exterior
slot with a reference count greater than one, the structure is
automatically duplicated, and the now-private copy is written to.

Having an acyclic ownership graph supports a ``semi-functional'' view
of values, in which memory structures are mutable, but always
@emph{effectively private} to the variable ``owning'' them. This
assumption is required by the typestate system, the communication
system and the slot transplanting system.

@item Structural algebraic data types

The Rust type system is structural rather than nominal (with the
exception of opaque module types), and contains the standard
assortment of useful ``algebraic'' type constructors from functional
languages, such as function types, tuples, record types, vectors, and
tagged disjoint unions.

@item Generic code

Rust supports a simple form of parametric polymorphism: functions,
types and modules can be parameterised by other types. Only one
constraint is modeled on type parameters: whether or not the parameter
type is @emph{limited} (transmittable over a channel). Beyond this,
type parameters are treated as opaque within the parameterised code.

@item Local type inference

To save some quantity of programmer key-pressing, Rust supports local
type inference: signatures of functions and programs always require
type annotation, but within the body of a function many types can be
declared @code{auto} and Rust will infer the type from its use in the
function.

@item Existential module system

Rust's module system is based on existential types with local
opening. It permits higher-order modules, module composition,
projection and indirection. Modules are both static binding constructs
and also first class values, but are (mostly) orthogonal to
compilation units..

@item Dynamic type

Rust includes support for slots of a top type, @code{any}, that can
hold any type of value whatsoever. An @code{any} slot is simply a pair
of a type code and an exterior value of that type. Injection into an
@code{any} and projection by type-case-selection is integrated into the
language.

@item Reflection

Rust supports runtime reflection on the structure of a crate, using
the same DWARF tables used to support the @code{any} type and various
other runtime services.

@item Metaprogramming

Rust supports a system for syntactic extension that can be loaded into
the compiler, to implement user-defined notations, macros,
program-generators and the like. These notations are @emph{marked}
using a special form of bracketing, such that a reader unfamiliar with
the extension can still parse the surrounding text by skipping over
the bracketed ``extension text''.

@item Exception and termination handling

Processes can fail at any time, due to internal or external sources of
error. A failure generates an exception value of type @code{any} that
causes a process to unwind its control stack, propagating the
exception outward from the failing frame until a handler is
located. If an exception propagates to a top level frame in a process,
the process will terminate.

Process termination due to an unhandled exception, in turn, causes the
Rust runtime to notify any @emph{linked} process via a registered
channel. This mechanism can be used to independently arrange
supervision and failure-recovery modes for groups of related
processes.

@item Deterministic destruction

Processes have destructors, which are executed deterministically in
bottom-up ownership order, when a process is terminated.

Similarly, the rules for releasing memory are deterministic: on
scope-exit, interior slots are released immediately, exterior slots
have their reference count decreased and are released if the count
drops to zero. Alias slots are not affected by scope exit.

@end itemize


@page
@node    Influences
@section Influences
@sp
@sp

@quotation
  The essential problem that must be solved in making a fault-tolerant
  software system is therefore that of fault-isolation. Different programmers
  will write different modules, some modules will be correct, others will have
  errors. We do not want the errors in one module to adversely affect the
  behaviour of a module which does not have any errors.

@flushright
                                   - Joe Armstrong
@end flushright
@end quotation
@sp
@sp

@quotation
  In our approach, all data is private to some process, and processes can
  only communicate through communications channels. @emph{Security}, as used
  in this paper, is the property which guarantees that processes in a system
  cannot affect each other except by explicit communication.

  When security is absent, nothing which can be proven about a single module
  in isolation can be guaranteed to hold when that module is embedded in a
  system [...]
@flushright
                                   - Robert Strom and Shaula Yemini
@end flushright
@end quotation
@sp
@sp

@quotation
  Concurrent and applicative programming complement each other. The
  ability to send messages on channels provides I/O without side effects,
  while the avoidance of shared data helps keep concurrent processes from
  colliding.
@flushright
                                   - Rob Pike
@end flushright
@end quotation
@sp
@sp

@page
Rust is not a particularly original language, though it may appear as such
since memory is so short in computer science. Its design elements are drawn
from a number of ``historical'' languages that have, with a few exceptions,
fallen out of favour. Four prominent lineages contribute the most:

@itemize
@sp
@item
The NIL (1981) and Hermes (1990) family. These languages were
developed by Robert Strom, Shaula Yemini, David Bacon and others in
their group at IBM Watson Research Center (Yorktown Heights, NY, USA).

@sp
@item
The Napier (1985) and Napier88 (1988) family. These languages were
developed by Malcolm Atkinson, Ron Morrison and others in their group
at the University of St. Andrews (St. Andrews, Fife, UK).

@sp
@item
The Erlang (1987) language, developed by Joe Armstrong, Robert
Virding, Claes Wikstr@"om, Mike Williams and others in their group at
the Ericsson Computer Science Laboratory (@"Alvsj@"o, Stockholm, Sweden) .

@sp
@item
The Newsqueak (1988), Alef (1995), and Limbo (1996) family. These languages
were developed by Rob Pike, Phil Winterbottom, Sean Dorward and others in
their group at Bell labs Computing Sciences Reserch Center (Murray Hill,
NJ, USA).
@end itemize

@sp
Additional influences can be seen from the ML family, Camlp4, and various
``pre-Object-Orientation'' languages of the 70s (CLU, Ada, Mesa, Alphard,
Euclid, etc.)

Rust is therefore, in many ways, a selection of language technologies that
were @emph{alternatives} to the historically dominant ``Object Oriented''
languages such as Smalltalk, C++, Java and Python.

@c ############################################################
@c tutorial
@c ############################################################

@c ############################################################
@c reference
@c ############################################################

@menu
* Ref.Comp::                    Compilation and component model.
* Ref.Comp.Crate::              Units of compilation, versioning, distribution and loading.
* Ref.Comp.Meta.Syntax::        Simple metaprogramming through syntax extension.
* Ref.Comp.Meta.General::       General-purpose staged compilation.

* Ref.Mem::                     Semantic model of memory.
* Ref.Mem.Alloc::               Memory allocation model.
* Ref.Mem.Own::                 Memory ownership model.
* Ref.Mem.Slot::                Memory containment and reference model.
* Ref.Mem.Init::                Initialisation state of memory.

* Ref.Proc::                    Semantic model of processes.
* Ref.Proc.Comm::               Inter-process communication.
* Ref.Proc.Life::               Process lifecycle and state transitions.
* Ref.Proc.Sched::              Process scheduling model.

* Ref.Run::                     Organisation of runtime services.
* Ref.Run.Mem::                 Runtime memory management service.
* Ref.Run.Comp::                Runtime dynamic compilation service.
* Ref.Run.Load::                Runtime component loading service.
* Ref.Run.Comm::                Runtime communication multiplexing service.
* Ref.Run.Refl::                Runtime reflection system.
* Ref.Run.Fault::               Runtime fault handler.

* Ref.Type::                    The types of values held in memory.
* Ref.Type.Any::                An open sum of every possible type.
* Ref.Type.Mach::               Machine-level types.
* Ref.Type.Prim::               Primitive types.
* Ref.Type.Int::                The arbitrary-precision integer type.
* Ref.Type.Text::               Strings and characters.
* Ref.Type.Rec::                Fixed products of heterogeneous types.
* Ref.Type.Tup::                Fixed products of homogeneous types.
* Ref.Type.Vec::                Open products of homogeneous types.
* Ref.Type.Tag::                Closed sums of heterogeneous types.
* Ref.Type.Fn::                 Subroutines and scoped coroutine types.
* Ref.Type.Port::               Unique inter-process message-receipt endpoints.
* Ref.Type.Chan::               Copyable inter-process message-sending capabilities.
* Ref.Type.Proc::               General coroutine-instance types.
* Ref.Type.Prog::               General coroutine-description types.
* Ref.Type.Mod::                Collections of items.
* Ref.Type.Type::               Types describing types.
* Ref.Type.Quote::              Types describing source code.

* Ref.Stat::                    Static structure of modules.
* Ref.Stat.Item::               The contents of a module.
* Ref.Stat.Item.Type::          Items defining the types of values and slots.
* Ref.Stat.Item.Fn::            Items defining functions.
* Ref.Stat.Item.Pred::          Items defining typestate predicates.
* Ref.Stat.Item.Mod::           Items defining sub-modules.
* Ref.Stat.Item.Prog::          Items defining programs.
* Ref.Stat.Slot::               Components of structures and control frames.
* Ref.Stat.Slot.Constr::        A set of predicates holding over a set of slots.
* Ref.Stat.Slot.Type::          Static types of slots.
* Ref.Stat.Slot.Type.Form::     Interpretation of a slot's memory.
* Ref.Stat.Slot.Type.Constr::   Constraints implied by a slot's type.
* Ref.Stat.Stmt::               Program execution as sequences of statements.
* Ref.Stat.Stmt.Point::         Inter-statement positions of logical judgments.
* Ref.Stat.Stmt.CFG::           The control flow graph formed by statements.
* Ref.Stat.Stmt.Typestate::     Constraints that hold at points.
* Ref.Stat.Stmt.Cond::          Constraints required and implied by a statement.
* Ref.Stat.Stmt.Check::         Relating dynamic state to static typestate.

@c nb: language needs ``be'' (become) to explicitly say when you want
@c local dtors to run.  ``ret'' (return) means ``after expr'', ``be''
@c means ``before expr''. It is also required for algorithmic
@c correctness in a variety of patterns; since there are
@c call-expressions that cannot be tail-calling (such as those that
@c pass aliases to locals) it is better to require the programmer to
@c signal their intent; we can then check and complain if their intent
@c cannot be satisfied.
@c
@c you can remove this note, but do not remove ``be'' from the language.
@c
@c Hmm, now I am not sure about that: you can always insist that
@c ret-calls *mean* tail calls and when they cannot be satisfied as
@c such, you just split the ret statement from the call-statement or
@c call-expr line. Minimality argues for this. But no, this means a user
@c may need a tail-call and (stupidly) write a non-tail call, leaving
@c the splitting to discovery during debugging. Not good. Keep ``be''.

* Ref.Stmt.Be::                 Statement for stopping and executing a tail call.
* Ref.Stmt.Ret::                Statement for stopping and producing a value.
* Ref.Stmt.Put::                Statement for pausing and producing a value.
* Ref.Stmt.Fail::               Statement for nonlocal control transfer during failure.
* Ref.Stmt.Log::                Statement for logging values to diagnostic buffers.
* Ref.Stmt.While::              Statement for simple conditional looping.
* Ref.Stmt.For::                Statement for complex conditional looping.
* Ref.Stmt.If::                 Statement for simple conditional branching.
* Ref.Stmt.Alt::                Statement for complex conditional branching.
* Ref.Stmt.Prove::              Statement for static assertion of typestate.
* Ref.Stmt.Check::              Statement for dynamic assertion of typestate.
* Ref.Stmt.IfCheck::            Statement for dynamic testing of typestate.

@c note that ``prove'' is probably un-necessary. If you are going to
@c *need* to acquire a typestate p(X,Y,Z) in order to verify a
@c statement, and it can be acquired purely using static predicates,
@c surely the typestate system can check the inputs to the static
@c predicate p(...) and chain backwards into the existing prestate?
@c This should not be a problem.
@c
@c I suppose the key to 'prove' is error reporting: you can 'prove'
@c something at a particular point in the program even if you are not
@c sure how you're intending to use it. Might otherwise find it hard
@c to understand the error messages.
@c
@c FIXME: make sure you *have* a way of declaring static
@c predicates. It's simple, you just use an equals sign: pred
@c foo(a,b,c) = bar(a,b), baz(b,c);

@end menu


@node    Reference
@chapter Reference

@c * Ref.Comp::                    Compilation and component model.
@c * Ref.Comp.Crate::              Units of compilation, versioning, distribution and loading.
@c NOTE influences: SML CM, Mesa Configurations, owens/flatt "units"

@c * Ref.Comp.Meta.Syntax::        Simple metaprogramming through syntax extension.
@c NOTE influences: camlp4

@c * Ref.Comp.Meta.General::       General-purpose staged compilation.

@node    Ref.Mem
@section Ref.Mem
@c * Ref.Mem::                     Semantic model of memory.

A Rust program's memory consists of a static set of @emph{items}, a
set of processes each with its own @emph{stack}, and a @emph{heap}
shared by all processes.

Allocations in the stack and the heap consist of @emph{slots}.

@node    Ref.Mem.Alloc
@section Ref.Mem.Alloc
@c * Ref.Mem.Alloc::               Memory allocation model.

The @dfn{items} of a program are those functions, modules, types, and
other artifacts that have their value calculated at compile time and
stored uniquely in the memory image of the rust process. Items are
neither dynamically allocated nor freed.

The @dfn{stack} consists of activation frames automatically allocated
on entry to each function as the program executes. A stack allocation
is reclaimed when control leaves the frame containing it.

The @dfn{heap} consists of an acyclic reference graph of
reference-counted, copy-on-write allocations made explicitly by
memory-allocating statements. A heap allocation lives until the last
reference to it drops, at which point it is automatically reclaimed.

@node    Ref.Mem.Own
@section Ref.Mem.Own
@c * Ref.Mem.Own::                 Memory ownership model.

A process @emph{directly owns} all the dynamic allocations in its
stack and @emph{lazily owns} all the dynamic allocations in the heap
reachable through references originating in its stack. A process does
not own any items.

@dfn{Direct ownership} of an allocation means that the owning process
is the only process that can access the allocation.

@dfn{Lazy ownership} of an allocation means that the owning process
is the only process that can @emph{observe its own modifications} to the
allocation.

When a process dies, its directly owned (stack) allocations are all
released, and its references to lazily owned (heap) allocations are
dropped, decrementing their reference counts.

@node    Ref.Mem.Slot
@section Ref.Mem.Slot
@c * Ref.Mem.Slot::                Memory containment and reference model.

A @dfn{slot} is a component of an allocation. A slot either holds a
value or the address of another allocation. Every slot has one of four
possible @emph{modes}.

The possible @dfn{modes} of a slot are:
@itemize
@item interior mode
The slot holds the value of the slot.

@item exterior mode
The slot holds the address of a reference-counted, copy-on-write heap
allocation that holds the value of the slot.

@item write-alias mode
The slot holds the address of a value. The referenced value may reside
within a stack allocation or a heap allocation. If the referenced
value resides within a heap allocation, the heap allocation is
necessarily unshared: it has reference count equal to 1.

@item read-alias mode
The meaning of the slot is the same as if it were in write-alias mode,
but the value can only be read from the slot, not written to.
@end itemize

@node    Ref.Mem.Init
@section Ref.Mem.Init
@c * Ref.Mem.Init::                Initialisation state of memory.

A slot is either initialised or uninitialised at every point in a
program. An @dfn{initialised} slot is one that holds a value. An
@dfn{uninitialised} slot is one that has not yet had a value copied
into it, or has had its value deleted, and so holds undefined
memory. The typestate system ensures that an uninitialised slot cannot
be read, but can be written to. A slot becomes initialised in any
statement that writes to it, and remains initialised until explicitly
destroyed or until its enclosing allocation is destroyed.


@node    Ref.Proc
@section Ref.Proc
@c * Ref.Proc::                    Semantic model of processes.

A executing Rust program is called a @dfn{process}. Each Rust process
has an identity, a stack, a set of outgoing communication channels and
incoming communication ports, and lazy ownership of some portion of
the heap of a single operating-system process.

Multiple Rust processes may coexist in a single operating-system
process. Execution of multiple Rust processes in a single
operating-system process may be either truly concurrent or interleaved
by the Rust runtime scheduler. Rust processes are lightweight: each
consumes less memory than an operating-system process, and switching
between Rust processes is faster than switching between
operating-system processes.

@node    Ref.Proc.Comm
@section Ref.Proc.Comm
@c * Ref.Proc.Comm::               Inter-process communication.

With the exception of @emph{unsafe} constructs, Rust processes are
isolated from interfering with one another's memory directly. Instead
of manipulating shared storage, Rust processes communicate with one
another using an explicit, typed, asynchronous, half-duplex
message-passing system.

A @dfn{port} is a communication endpoint that can @emph{receive}
messages. Ports receive messages from channels.

A @dfn{channel} is a communication endpoint that can @emph{send}
messages. Channels send messages to ports.

Each port has a unique identity and cannot be replicated. New ports
can be constructed at any time. Each channel is bound to a port when
it is constructed, so the destination port for a channel must exist before
the channel itself. A channels cannot be rebound to a different port than
the one it was constructed with.

Many channels can be bound to the same port, but each channel is bound
to a single port. In other words, channels and ports exist in an N:1
relationship, N channels to 1 port, where N is a non-negative integer.

Each port and channel can carry only one type of message. The message type
is encoded as a parameter of the channel or port type. The message type
of a channel is equal to the message type of the port it is bound to.

Messages are sent asynchronously or semi-synchronously. A channel
contains a message queue and asynchronously sending a message merely
inserts it into the channel's queue; message receipt is the
responsibility of the receiving process.

Queued messages in channels are considered part of the memory budget
of the sending process. If too many messages are queued for
transmission from a single sending process, without being received by
a receiving process, the sending process may exceed its memory budget
and be terminated. To help control this possibility, a
semi-synchronous send operation is possible, which performs an
asynchronous send operation and then blocks execution of the sending
process until the queue for the channel being sent to
empties. Semi-synchronous sending does @emph{not} guarantee that a
message has been @emph{received} by any particular recipient when the
sending process is unblocked; merely that the message @emph{has been
sent} and is no longer in the queue owned by the sending process.


@node    Ref.Proc.Life
@section Ref.Proc.Life
@c * Ref.Proc.Life::               Process lifecycle and state transitions.

@node    Ref.Proc.Sched
@section Ref.Proc.Sched
@c * Ref.Proc.Sched::              Process scheduling model.

@c * Ref.Run::                     Organisation of runtime services.
@c * Ref.Run.Mem::                 Runtime memory management service.
@c * Ref.Run.Comp::                Runtime dynamic compilation service.
@c * Ref.Run.Load::                Runtime component loading service.
@c * Ref.Run.Comm::                Runtime communication multiplexing service.
@c * Ref.Run.Refl::                Runtime reflection system.
@c * Ref.Run.Fault::               Runtime fault handler.


@node    Ref.Type
@section Ref.Type

Every slot and value in a Rust program has a type. The @dfn{type} of a
@emph{value} defines the interpretation of the memory holding it. The
type of a @emph{slot} may also include constraints, @xref{Ref.Stat.Slot.Type.Constr}.

Some types and type-constructors are @dfn{built-in}, meaning that
their value constructors are defined in this manual. Other types or
type-constructors are @dfn{user-defined}, meaning that their value
constructors depend on portions of user programs.

Built-in types and type-constructors are tightly integrated into the
language, in nontrivial ways that are not possible to emulate in
user-defined types. User-defined types have limited capabilities. In
addition, every built-in type or type-constructor name is reserved as
a @emph{keyword} in Rust; they cannot be used as user-defined
identifiers in any context.


@node    Ref.Type.Any
@section Ref.Type.Any

The type @code{any} is the union of all possible Rust types. A value
of type @code{any} is represented in memory as a pair consisting of an
exterior value of some non-@code{any} type @var{T} and a reflection
of the type @var{T}.

Values of type @code{any} can used in an @code{alt type} statement, in
which the reflection is used to select a block corresponding to a
particular type extraction. @xref{Ref.Stmt.Alt}.

@node    Ref.Type.Mach
@section Ref.Type.Mach

The machine types are the following:

@itemize
@item
The unsigned two's complement word types @code{u8}, @code{u16},
@code{u32} and @code{u64}, with values drawn from the integer
intervals @math{[0,(2^8)-1)]}, @math{[0,(2^16)-1)]},
@math{[0,(2^32)-1)]} and @math{[0,(2^64)-1)]} respectively.
@item
The signed two's complement word types @code{s8}, @code{s16}, @code{s32} and @code{s64},
with values drawn from the integer
intervals @math{[-(2^7),(2^7)-1)]}, @math{[-(2^15),(2^15)-1)]},
@math{[-(2^31),(2^31)-1)]} and @math{[-(2^63),(2^63)-1)]} respectively.
@item
The IEEE 754 double-precision floating point type @code{f64}.
@end itemize

In addition to these types, any symbols consisting of a single
lowercase letter in the ASCII range @code{a-z} followed by a sequence
of 1 or more decimal digits is reserved as a future machine type in
a later version of the Rust language.


@node    Ref.Type.Prim
@section Ref.Type.Prim

The primitive types are the following:

@itemize
@item
The type @code{nil}, having the single value @code{nil}.
@item
The boolean type @code{bool} with values @code{true} and @code{false}.
@item
The machine types.
@end itemize

@node    Ref.Type.Int
@section Ref.Type.Int

Unlike many C-family languages, in Rust the type @code{int} is not
defined as a fixed-size machine word type. Instead, it is an arbitrary
precision type that fits in a machine word @emph{when possible} and
transparently expands to a boxed ``big integer'' allocated in the
runtime heap when it overflows or underflows outside of the range of a
machine word.

A Rust @code{int} grows to accommodate extra binary digits as they are
needed, by taking extra memory from the dynamic memory pool available
to each Rust process, and should only exhaust its range due to memory
exhaustion.

@node    Ref.Type.Text
@section Ref.Type.Text

The types @code{char} and @code{str} hold textual data.

A value of type @code{char} is a Unicode character, represented as a
32-bit unsigned word holding a UCS-4 codepoint.

A value of type @code{str} is a Unicode string, represented as a
vector of 8-bit unsigned words holding a UTF-8 codepoints.

@node    Ref.Type.Rec
@section Ref.Type.Rec

The record type-constructor @code{rec} forms new heterogeneous product
of slots. It is analogous to the @code{struct} type-constructor in
C. Fields of a @code{rec} type are accessed by name and are arranged
in memory in the order specified by the @code{rec} type.

An example of a @code{rec} type and its use:
@example
type point = rec(int x, int y);
let point p = rec(x=10, y=11);
let int px = p.x;
@end example

@node    Ref.Type.Tup
@section Ref.Type.Tup

The tuple type-constructor is a parenthesised, comma-separated list of
two or more slots. It exactly mirrors the tuple value-constructor,
itself a comma-separated list of two or more values.

Tuples are equivalent to records labeled by ascending integers
starting from 0: their fields are laid out in memory contiguously, in
order specified by the tuple type. Tuples can only be indexed by
static numeric labels enclosed in braces. Tuples can also be
``destructured'' into named constituents, in various syntactic
contexts, such as in a tuple initialisation statement or a function
parameter list.

An example of a tuple type and its use:
@example
type pair = (int,str);
let pair p = (10,"hello");
check (p.@{0@} == 10);
p.@{1@} = "world";
let (int x, str s) = p;
check (s == p.@{1@} & p.@{1@} == "world");
@end example


@node    Ref.Type.Vec
@section Ref.Type.Vec

The vector type-constructor @code{vec} represents a homogeneous,
variable-size array of slots. Vectors automatically resize to
accommodate the addition or removal of elements. Elements can be
accessed by numeric index, but as with records and tuples, all
accessible elements are always initialised.

And example of a @code{vec} type and its use:
@example
let vec[int] v = vec(7, 5, 3);
let int i = v.(2);
@end example

@node    Ref.Type.Tag
@section Ref.Type.Tag

The @code{tag} type-constructor forms new heterogeneous
disjoint sum types. It is analogous to the @code{data} type-constructor
in ML. A @code{tag} type consists of a number of @code{variants}, each of
which is independently named and takes an optional tuple of arguments.

The variants of a @code{tag} type may be recursive: that is, the
definition of a @code{tag} type may refer to type definitions that
include the defined @code{tag} type itself. Such recursion can only be
introduced using @code{tag} type definitions. Every recursive
@code{tag} type must have at least one non-recursive variant, serving
as a base case for the recursion.

An example of a @code{tag} type and its use:
@example
type animal = tag(dog, cat);
let animal a = dog;
a = cat;
@end example

An example of a @emph{recursive} @code{tag} type and its use:
@example
type list[T] = tag[T](empty,
                      cons(T, @@list[T]));
let list[int] a = cons(7, cons(13, empty));
@end example


@node    Ref.Type.Fn
@section Ref.Type.Fn

The function type-constructor @code{fn} forms new function types. A
function type consists of an optional protocol, an input type, an
output type, and a set of flags indicating special characteristics of
the function (@code{pure} or @code{lim}).

An example of a simple @code{fn} type:
@example
fn add(int x, int y) -> int @{
  ret x + y;
@}

let int x = add(5,7);

type binop = fn(int,int) -> int;
let binop bo = add;
x = bo(5,7);
@end example


@node    Ref.Type.Port
@section Ref.Type.Port

The port type-constructor @code{port} forms types that describe
ports. A port is the @emph{receiving end} of a single-duplex
inter-process communication facility. @xref{Ref.Proc.Comm}. A
@code{port} type takes a single type parameter, denoting the type of
value that can be received from a @code{port} value of that type.

Ports are @emph{limited}: they cannot be transmitted through channels,
and can only be passed between processes during process
initialisation.

An example of a @code{port} type:
@example
type port[vec[str]] svp;
let svp p = get_port();
let vec[str] v;
v <- p;
@end example

@node    Ref.Type.Chan
@section Ref.Type.Chan

The channel type-constructor @code{chan} forms types that describe
channels. A channel is the @emph{sending end} of a single-duplex
inter-process communication facility. @xref{Ref.Proc.Comm}. A
@code{chan} type takes a single type parameter, denoting the type of
value that can be sent to a channel of that type.

Channels are general @emph{unlimited} values: they can be transmitted
between processes through channels. They are also @emph{weak}: a
channel is directly coupled to a particular destination port, but does
not keep that port @emph{alive}, and may therefore fail to operate at
any moment.

An example of a @code{chan} type:
@example
type chan[vec[str]] svc;
let svc c = get_chan();
let vec[str] v = vec("hello", "world");
c <| v;
@end example

@node    Ref.Type.Proc
@section Ref.Type.Proc

The process type @code{proc} describes values that are @emph{live
processes}.  Process values are opaque and @emph{limited}: they cannot
be directly inspected and they cannot be passed between processes,
over channels.

Processes form an @emph{ownership tree} in which each process (except
the root process) is directly owned by exactly one parent process. The
purpose of a variable of @code{proc} type is to manage the lifecycle
of the associated process. Communication is carried out solely using
channels and ports.


@node    Ref.Type.Prog
@section Ref.Type.Prog

The program type-constructor @code{prog} forms new program types. A
program type consists of a signature, similar to a function type with
no protocol, describing the inputs and outputs of the initialisation
routine for programs of that type.

When a program is called in a @emph{spawn expression}, the Rust
runtime creates a new process, then the spawning process runs the
program initialisation routine in the scope of the new process. The
value produced by the expression, in the spawning process, is a
2-tuple consisting of the new process value and the value returned
from the program initialisation routine. The spawned process then
begins running.

An example of a @code{prog} type:
@example
type stdio = rec(port[u8] stdin,
                 chan[u8] stdout,
                 chan[u8] stderr);
prog byte_copy @{
     let stdio io;
     init (chan[u8] out, chan[u8] err) -> chan @{
          io.stdin = port();
          io.stdout = out;
          io.stderr = err;
          ret chan(io.stdin);
     @}
     main @{
       u8 tmp;
       while (tmp <- io.in) @{
             io.out <| tmp;
       @}
     @}
@}

type stdio_prog = proc(chan[u8], chan[u8]) -> chan;

let stdio_prog cat = byte_copy;
let port[u8] out = port();
let port[u8] err = port();

let (proc p, chan[u8] in) = spawn cat(chan(out), chan(err));
@end example


@c * Ref.Type.Mod::                Units of information hiding.
@c * Ref.Type.Type::               Types describing types.
@c * Ref.Type.Quote::              Types describing source code.


@node    Ref.Stmt.Be
@section Ref.Stmt.Be
@c * Ref.Stmt.Be::                 Statement for stopping and executing a tail call.

Executing a @code{be} statement destroys the current function
activation frame and replaces it with an activation frame for the
called function. In other words, @code{be} executes a tail-call.

A @code{be} statement in Rust is analogous to a @code{become}
statement in the Newsqueak language.

An example of a @code{be} statement:
@example
fn print_loop(int n) -> nil @{
  if (n <= 0) @{
    ret;
  @} else @{
    print_int(n);
    be print_loop(n-1);
  @}
@}
@end example

The above example executes in constant space, replacing each frame
with a new copy of itself.


@node    Ref.Stmt.
@section Ref.Stmt.
@c * Ref.Stmt.Ret::                Statement for stopping and producing a value.

Executing a @code{ret} statement copies a value into the return slot
of the current function, destroys the current function activation
frame, and transfers control to the caller frame.

A @code{ret} statement in Rust is analogous to a @code{return}
statement in many C-family languages.

An example of a @code{ret} statement:
@example
fn max(int a, int b) -> int @{
   if (a > b) @{
      ret a;
   @}
   ret b;
@}
@end example

@node    Ref.Stmt.Put
@section Ref.Stmt.Put
@c * Ref.Stmt.Put::                Statement for pausing and producing a value.

Executing a @code{put} statement copies a value into the put slot of
the current iterator function, suspends execution of the current
iterator function, and transfers control to the current put-recipient
frame. The current put-recipient will eventually resume the suspended
iterator function containing the @code{put} statement, either
continuing execution after the @code{put} statement, or terminating
its execution and destroying the iterator function frame.

A @code{put} statement is analogous to a @code{yield} statement in the
CLU language, or in more recent languages providing a ``generator''
facility, such as Python, Javascript or C#. Like the generators of
CLU, and unlike these later languages, Rust's iterator functions
reside on the stack and obey a strict stack discipline.


@node    Ref.Stmt.Fail
@section Ref.Stmt.Fail
@c * Ref.Stmt.Fail::               Statement for nonlocal control transfer during failure.

Executing a @code{fail} statement initiates exception handling.

@node    Ref.Stmt.Log
@section Ref.Stmt.Log
@c * Ref.Stmt.Log::                Statement for logging values to diagnostic buffers.

Executing a @code{log} statement may, depending on system
configuration, cause a value to be appended to an internal diagnostic
logging buffer provided by the Rust runtime. Log statements are
enabled or disabled dynamically at runtime on a per-process,
per-module and per-function basis.

Appending to the logging buffer is not considered a ``side effect''
for the purposes of differentiating pure and impure functions. In
other words, a pure function remains pure even if it contains a log
statement.

@example
@end example

@node    Ref.Stmt.While
@section Ref.Stmt.While
@c * Ref.Stmt.While::              Statement for simple conditional looping.

A @code{while} statement is a loop construct. The loop begins with an
evaluation of the boolean loop-head expression. If the loop-head
expression evaluates to @code{true}, the loop-body block executes and
control returns to the loop-head expression. If the loop-head
expression evaluates to @code{false}, the @code{while} statement
completes.

An example of a @code{while} statement:
@example
while (i < 10) @{
  print("hello\n");
  i = i + 1;
@}
@end example


@node    Ref.Stmt.For
@section Ref.Stmt.For
@c * Ref.Stmt.For::                Statement for complex conditional looping.

A @code{for} statement is a loop construct. There are two types of
@code{for} statement: range for-loops and iterator for-loops.

A @emph{range} for-loop is controlled by a range tuple, either a
2-tuple or a 3-tuple describing a bounded arithmetic sequence of
indices to be selected from a vector or string. The range for-loop
bounds-checks the sequence @emph{once} when initiating the loop, then
repeatedly assigns the index variable and/or element variable of the
loop each value in the sequence (and/or its selected element),
executing the loop body once per assignment.

@example
let vec[foo] v = vec(a, b, c);
for (~foo e = v.(0, vec.len(v))) @{
  bar(e);
@}
@end example

An @emph{iterator} for-loop is controlled by an iterator function. The
for loop executes once for each value @code{put} by the iterator
function.  When the iterator function returns or fails, the loop
terminates.

@example
str txt;
vec[str] lines;
for (~str s = str.split(txt, "\n")) @{
  vec.push(lines, s);
@}
@end example


@node    Ref.Stmt.If
@section Ref.Stmt.If
@c * Ref.Stmt.If::                 Statement for simple conditional branching.

@node    Ref.Stmt.Alt
@section Ref.Stmt.Alt
@c * Ref.Stmt.Alt::                Statement for complex conditional branching.

@node    Ref.Stmt.Prove
@section Ref.Stmt.Prove
@c * Ref.Stmt.Prove::              Statement for static assertion of typestate.

A @code{prove} statement has no runtime effect. Its purpose is to
check, statically, that its argument typestate holds at its statement
entry point. If its argument typestate does not hold, under the
typestate algorithm, the program containing it will fail to compile.

@node    Ref.Stmt.Check
@section Ref.Stmt.Check
@c * Ref.Stmt.Check::              Statement for dynamic assertion of typestate.

A @code{check} statement connects dynamic assertions made at runtime
to the static typestate system. A @code{check} statement takes a
condition to check at runtime. If the condition holds at runtime,
control passes through the @code{check} and on to the next statement
in the enclosing block. If the condition fails to hold at runtime, the
@code{check} statement behaves as a @code{fail} statement, raising an
exception.

The typestate algorithm is built around @code{check} statements, and
in particular the fact that control @emph{will not pass} a check
statement with a condition that fails to hold. The typestate algorithm
can therefore assume that the (static) postcondition of a @code{check}
statement includes the checked condition itself. From there, the
typestate algorithm can perform dataflow calculations on subsequent
statements, propagating conditions forward and statically comparing
implied states and their specifications.

@example
pred even(~int x) @{
    ret x & 1 == 0;
@}

fn print_even(int x) : even(x) -> () @{
    print(x);
@}

fn test() @{
    let int y = 8;

    // Could not call print_even(y) here.

    check even(y);

    // can call print_even(y) here, since even(y) now holds.
    print_even(y);
@}
@end example

@node    Ref.Stmt.IfCheck
@section Ref.Stmt.IfCheck
@c * Ref.Stmt.IfCheck::            Statement for dynamic testing of typestate.

An @code{if check} statement combines a @code{if} statement and a
@code{check} statement in a unique pair that can be used to build more
complex conditional control flow than the @code{check} statement
affords.

In fact, @code{if check} is a ``more primitive'' statement
@code{check}; instances of the latter can be rewritten as instances of
the former. The following two examples are equivalent:

@example
check even(x);
print_even(x);
@end example

@example
if check(even(x)) @{
    print_even(x);
@} else @{
    fail;
@}
@end example

@node    Ref.Stat
@section Ref.Stat
@c * Ref.Stat::                    Static structure of modules.

A Rust module contains declarations of @emph{items}. Items may include
functions, programs, sub-modules, or type and typestate declarations
used during the static analysis phase of compilation.

The static structure of a module is analysed during compilation to
ensure a variety of rules are obeyed, as well as to determine the
static information required to produce the compiled form of the
module. The static rules include those defining slot visibility and
value ownership, type inference and checking, and typestate inference
and checking.

@node    Ref.Stat.Item
@section Ref.Stat.Item
@c * Ref.Stat.Item::               The contents of a module.

An @dfn{item} is a component of a module. Items are entirely
determined at compile time, remain constant during execution, and may
reside in read-only memory.

There are 5 primary kinds of item: types, functions, predicates,
modules, and programs.

@node    Ref.Stat.Item.Type
@section Ref.Stat.Item.Type
@c * Ref.Stat.Item.Type::          Items defining the types of values and slots.

A @dfn{type} defines an @emph{interpretation} of a value in memory. A
type's interpretation is used for the values held in any slot with
that type. The interpretation of a value includes:

@itemize
@item Whether the value is composed of sub-values or is indivisible
@item Whether the value represents textual or numerical information
@item Whether the value represents integral or floating-point information
@item The sequence of memory operations required to access the value
@end itemize

For example, the type @code{rec(u8 x, u8 y)} defines the
interpretation of values that are composite records, each containing
two unsigned two's complement 8-bit integers accessed through the
components @code{x} and @code{y}, and laid out in memory with the
@code{x} component preceding the @code{y} component.

@node    Ref.Stat.Item.Fn
@section Ref.Stat.Item.Fn
@c * Ref.Stat.Item.Fn::            Items defining functions.

A @dfn{function} defines a sequence of statements. Functions are
declared with the keyword @code{fn}.

There are two primary kinds of functions: plain functions and iterator
functions. Iterator functions are those that are said to have a
@emph{protocol}. A protocol defines how many values (in a
``zero-one-infinity'' counting sense) the iterator function will
@code{put} before it executes a @code{ret} statement. Protocols are
indicated by a variant of the @code{fn} keyword, as follows:

@itemize
@item
@code{fn?} indicates a function that will put either 0 or 1 value, then return.
@item
@code{fn!} indicates a function that will put exactly 1 value, then return.
@item
@code{fn*} indicates a function that will put 0 or more values, then return.
@item
@code{fn+} indicates a function that will put 1 or more values, then return.
@end itemize

If a function has a protocol, the output type is the type of value
that the function will @code{put}. If a function has no protocol, the
output type is the type of value the function will @code{ret}.

An example of a plain @code{fn} (with no protocol):
@example
fn add(int x, int y) -> int @{
  ret x + y;
@}
@end example

A function with a protocol can only be called in the loop header of a
matching @code{for} loop. For example a @code{fn+} function can only
be called from a @code{for+} loop header.

An example of a @code{fn} with a protocol:
@example
fn* range(int lo, int hi) -> int @{
  let int i = lo;
  while (i < hi) @{
    put i;
    i = i + 1;
  @}
@}

let int sum = 0;
for* (int x = range(0,100)) @{
    sum = sum + x;
@}
@end example

A function type may be @emph{pure} or @emph{impure}, depending on the
presence or absence of the keyword prefix @code{pure}. A @dfn{pure}
function is one that has no side effects, calls no impure functions,
and is declared with the @code{pure} keyword. A function lacking any
of these characteristics is @dfn{impure}. @xref{Ref.Stat.Item.Fn}.


@node    Ref.Stat.Item.Pred
@section Ref.Stat.Item.Pred
@c * Ref.Stat.Item.Pred::          Items defining typestate predicates.

A predicate is a pure function returning @code{bool}, that also
carries special meaning to the typestate system. Specifically, a
predicate can be used as part of a @emph{condition}; introducing a new
predicate into a program enlarges the set of conditions that
can be statically checked. @xref{Ref.Stat.Stmt.Typestate}.

@node    Ref.Stat.Item.Mod
@section Ref.Stat.Item.Mod
@c * Ref.Stat.Item.Mod::           Items defining sub-modules.

@node    Ref.Stat.Item.Prog
@section Ref.Stat.Item.Prog
@c * Ref.Stat.Item.Prog::          Items defining programs.

@c * Ref.Stat.Slot::               Components of structures and control frames.

@c * Ref.Stat.Slot.Constr::        A set of predicates holding over a set of slots.
@node    Ref.Stat.Stmt.Constr
@section Ref.Stat.Stmt.Constr

A @dfn{constraint} is a predicate applied to specific slots.

For example, consider the following code:

@example
pred is_less_than(int a, int b) @{
     ret a < b;
@}

fn test() @{
   int x = 10;
   int y = 20;
   check(is_less_than(x,y));
@}
@end example

This example defines the predicate @code{is_less_than}, and applies it
to the slots @code{x} and @code{y}. The constraint being checked on
the third line of the function is @code{is_less_than(x,y)}.

@c * Ref.Stat.Slot.Type::          Static types of slots.
@c * Ref.Stat.Slot.Type.Form::     Interpretation of a slot's memory.
@c * Ref.Stat.Slot.Type.Constr::   Constraints implied by a slot's type.
@c * Ref.Stat.Stmt::               Program execution as sequences of statements.


@node    Ref.Stat.Stmt.Point
@section Ref.Stat.Stmt.Point
@c * Ref.Stat.Stmt.Point::         Inter-statement positions of logical judgments.

A @dfn{point} exists before and after any statement in a Rust program.
For example, this code:

@example
 s = "hello, world";
 print(s);
@end example

Consists of two statements and three points:

@itemize
@item the point before the first statement
@item the point between the two statements
@item the point after the second statement
@end itemize

The typestate system reasons over points, rather than statements. This
may seem counterintuitive, but points are the more primitive
concept. Another way of thinking about a point is as a set of
@emph{instants in time} at which the state of the machine is fixed. By
contrast, a statement represents a @emph{duration in time}, during
which the state of the machine changes. The typestate system is
concerned with constraining the possible states of a machine's memory
at @emph{instants}; it is meaningless to speak of the state of a
machine's memory ``at'' a statement, as each statement is likely to
change the contents of memory.

@node    Ref.Stat.Stmt.CFG
@section Ref.Stat.Stmt.CFG
@c * Ref.Stat.Stmt.CFG::           The control flow graph formed by statements.

Each @emph{point} can be considered a vertex in a directed
@emph{graph}. Each kind of statement implies a single edge in this
graph between the point before the statement and the point after it,
as well as a set of zero or more edges from the points of the
statement to points before other statements. The edges between points
represent @emph{possible} indivisible control transfers that might
occur during execution.

This implicit graph is called the @dfn{control flow graph}, or @dfn{CFG}.

@node    Ref.Stat.Stmt.Cond
@section Ref.Stat.Stmt.Cond
@c * Ref.Stat.Stmt.Cond::          Constraints required and implied by a statement.

A @dfn{condition} is a set of zero or more constraints.

Each @emph{point} has an associated @emph{condition}:

@itemize
@item The @dfn{precondition} of a statement is the condition the statement requires in the point before the condition.
@item The @dfn{postcondition} of a statement is the condition the statement enforces in the point after the statement.
@end itemize

Any constraint present in the precondition and @emph{absent} in the
postcondition is considered to be @emph{dropped} by the statement.

@node    Ref.Stat.Stmt.Typestate
@section Ref.Stat.Stmt.Typestate
@c * Ref.Stat.Stmt.Typestate::     Constraints that hold at points.

The typestate checking system @emph{calculates} an additional
condition for each point called its typestate. For a given statement,
we call the two typestates associated with its two points the prestate
and a poststate.

@itemize
@item The @dfn{prestate} of a statement is the typestate of the point before the statement.
@item The @dfn{poststate} of a statement is the typestate of the point after the statement.
@end itemize

A @dfn{typestate} is a condition that has @emph{been determined by the
typestate algorithm} to hold at a point. This is a subtle but
important point to understand: preconditions and postconditions are
@emph{inputs} to the typestate algorithm; prestates and poststates are
@emph{outputs} from the typestate algorithm.

The typestate algorithm analyses the preconditions and postconditions
of every statement in a block, and attempts to compute a condition for
each typestate. Specifically:

@itemize
@item Initially, every typestate is empty.
@item Each statement's poststate is given the union of the statement's prestate, precondition, and postcondition.
@item Each statement's poststate has the difference between the statement's precondition and postcondition removed.
@item Each statement's prestate is given the intersection of the poststates of every parent statement in the CFG.
@item The previous three steps are repeated until no typestates in the block change.
@end itemize

The typestate algorithm is a very conventional dataflow calculation.

After the typestates of a block are computed, the typestate algorithm
checks that every constraint in the precondition of a statement is
satisfied by its prestate. If any preconditions are not satisfied and
no automatic assertions exist, the mismatch is considered an error.


@c * Ref.Stat.Stmt.Check::         Relating dynamic state to static typestate.


@c ############################################################
@c end main body of nodes
@c ############################################################

@node Index

@printindex cp

@bye
