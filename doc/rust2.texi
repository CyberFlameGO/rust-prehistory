\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename rust.info
@settitle Rust Documentation
@setchapternewpage odd
@c %**end of header

@syncodeindex fn cp

@ifinfo
This manual is for the ``Rust'' programming language.

Copyright 2005-2008 Graydon Hoare

All rights reserved

Licensed to the public under the terms of the GNU GPL (>= 2.0).
See the file COPYING for details
@end ifinfo

@dircategory Programming
@direntry
* rust: (rust).         Rust programming language
@end direntry

@titlepage
@title Rust
@subtitle A general-purpose programming language
@author Graydon Hoare

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2005-2008 Graydon Hoare
All rights reserved
Licensed to the public under the terms of the GNU GPL (>= 3.0).
See the file COPYING for details
@end titlepage

@ifnottex
@node Top
@top Top

Rust Documentation

Rust is a general-purpose programming language. It supports imperative
procedural, concurrent actor and pure functional styles. Rust also
supports generic programming and metaprogramming, in both static and
dynamic styles.

@end ifnottex

@menu
* Introduction::               Background, intentions, relationships to other languages
* Tutorial::                   Gentle introduction to reading Rust code
* Reference::                  Systematic reference of language elements
@end menu

@ifnottex
Complete table of contents
@end ifnottex

@contents

@node    Introduction
@chapter Introduction

@quotation
  We have to fight chaos, and the most effective way of doing that is
  to prevent its emergence. We have to learn to avoid all forms of
  combinatorial complexity generators that, when active, rapidly tax
  our ability to carry out a case-analysis far beyond the limits of our
  power of reasoning. [...] A great advantage is that we know at least
  what we are looking for, and [...] that a terminology is emerging
  [...] in which we can answer the otherwise frustrating question that so
  often emerges in the midst of one's struggles in ``What the hell am
  I really doing?''

@flushright
                                   - Edsger Dijkstra
@end flushright
@end quotation
@sp
@sp

Rust is a ``curly-brace'' block-structured statement language. It
visually resembles the Algol / C family, but differs significantly in
syntactic and semantic details.

@node    Goals
@section Goals

The language design pursues the following goals:

@sp
@itemize
@item Compile-time error detection and prevention.
@item Run-time error isolation and containment.
@item Internet-scale system construction.
@item Loose coupling.
@item System analysis and maintainance affordances.
@item Clarity and precision of expression.
@item Implementation simplicity.
@item Run-time efficiency.
@end itemize
@sp

Note that most of these goals are @emph{engineering} goals, not showcases
for sophisticated language technology. Most of the technology in rust is
@emph{old} and has been seen decades earlier in other languages.

Also note that ``terseness'' and ``expressiveness'' are absent from the
list. Rust programs are often larger and more verbose than equivalent
programs in other languages. The syntax avoids gratuitous chatter where
possible, and keywords are kept modest, but rust is unlikely to win any
competitions for ``shortest program to accomplish a given task''.

@page
@node    Influences
@section Influences
@sp
@sp

@quotation
  The essential problem that must be solved in making a fault-tolerant
  software system is therefore that of fault-isolation. Different programmers
  will write different modules, some modules will be correct, others will have
  errors. We do not want the errors in one module to adversely affect the
  behaviour of a module which does not have any errors.

@flushright
                                   - Joe Armstrong
@end flushright
@end quotation
@sp
@sp

@quotation
  In our approach, all data is private to some process, and processes can
  only communicate through communications channels. @emph{Security}, as used
  in this paper, is the property which guarantees that processes in a system
  cannot affect each other except by explicit communication.

  When security is absent, nothing which can be proven about a single module
  in isolation can be guaranteed to hold when that module is embedded in a
  system [...]
@flushright
                                   - Robert Strom and Shaula Yemini
@end flushright
@end quotation
@sp
@sp

@quotation
  Concurrent and applicative programming complement each other. The
  ability to send messages on channels provides I/O without side effects,
  while the avoidance of shared data helps keep concurrent processes from
  colliding.
@flushright
                                   - Rob Pike
@end flushright
@end quotation
@sp
@sp

@page
Rust is not a particularly original language, though it may appear as such
since memory is so short in computer science. Its design elements are drawn
from a number of ``historical'' languages that have, with a few exceptions,
fallen out of favour. Four prominent lineages contribute the most:

@itemize
@sp
@item
The NIL (1981) and Hermes (1990) family. These languages were
developed by Robert Strom, Shaula Yemini, David Bacon and others in
their group at IBM Watson Research Center (Yorktown Heights, NY, USA).

@sp
@item
The Napier (1985) and Napier88 (1988) family. These languages were
developed by Malcolm Atkinson, Ron Morrison and others in their group
at the University of St. Andrews (St. Andrews, Fife, UK).

@sp
@item
The Erlang (1987) language, developed by Joe Armstrong, Robert
Virding, Claes Wikstr@"om, Mike Williams and others in their group at
the Ericsson Computer Science Laboratory (@"Alvsj@"o, Stockholm, Sweden) .

@sp
@item
The Newsqueak (1988), Alef (1995), and Limbo (1996) family. These languages
were developed by Rob Pike, Phil Winterbottom, Sean Dorward and others in
their group at Bell labs Computing Sciences Reserch Center (Murray Hill,
NJ, USA).
@end itemize

@sp
Additional influences can be seen from SML, Camlp4, and various
``pre-Object-Orientation'' languages of the 70s (CLU, Ada, Mesa, Alphard,
Euclid, etc.)

Rust is therefore, in many ways, a selection of language technologies that
were @emph{alternatives} to the historically dominant ``Object Oriented''
languages such as Smalltalk, C++, Java and Python.


@c ############################################################
@c begin main body of nodes
@c ############################################################

@c ############################################################
@c introduction
@c ############################################################

@c ############################################################
@c tutorial
@c ############################################################

@c ############################################################
@c reference
@c ############################################################

@menu
* Ref.Comp::                    Compilation and component model.
* Ref.Comp.Crate::              Units of compilation, versioning, distribution and loading.
* Ref.Comp.Meta.Syntax::        Simple metaprogramming through syntax extension.
* Ref.Comp.Meta.General::       General-purpose staged compilation.

* Ref.Mem::                     Semantic model of memory.
* Ref.Mem.Alloc::               Memory allocation model.
* Ref.Mem.Own::                 Memory ownership model.
* Ref.Mem.Slot::                Memory containment and reference model.

* Ref.Proc::                    Semantic model of processes.
* Ref.Proc.Comm::               Inter-process communication.
* Ref.Proc.Life::               Process lifecycle and state transitions.
* Ref.Proc.Sched::              Process scheduling model.

* Ref.Run::                     Organization of runtime services.
* Ref.Run.Mem::                 Runtime memory management service.
* Ref.Run.Comp::                Runtime dynamic compilation service.
* Ref.Run.Load::                Runtime component loading service.
* Ref.Run.Comm::                Runtime communication multiplexing service.
* Ref.Run.Refl::                Runtime reflection system.
* Ref.Run.Fault::               Runtime fault handler.

* Ref.Type::                    The types of values held in memory.
* Ref.Type.Any::                An open sum of every possible type.
* Ref.Type.Prim::               Primitive machine-level types.
* Ref.Type.Int::                The arbitrary-precision integer type.
* Ref.Type.Text::               Strings and characters.
* Ref.Type.Rec::                Fixed products of heterogeneous types.
* Ref.Type.Vec::                Open products of homogeneous types.
* Ref.Type.Alt::                Closed sums of heterogeneous types.
* Ref.Type.Fn::                 Subroutines and scoped coroutine types.
* Ref.Type.Port::               Unique inter-process message-receipt endpoints.
* Ref.Type.Chan::               Copyable inter-process message-sending capabilities.
* Ref.Type.Proc::               General coroutine-instance types.
* Ref.Type.Prog::               General coroutine-description types.
* Ref.Type.Mod::                Units of information hiding.
* Ref.Type.Type::               Types describing types.
* Ref.Type.Quote::              Types describing source code.

* Ref.Stat::                    Static structure of programs.
* Ref.Stat.Pred::               Static predicates covering dynamic judgments.
* Ref.Stat.Slot::               Components of structures and control frames.
* Ref.Stat.Slot.Constr::        A set of predicates holding over a set of slots.
* Ref.Stat.Slot.Type::          Static types of slots.
* Ref.Stat.Slot.Type.Form::     Interpretation of a slot's memory.
* Ref.Stat.Slot.Type.Constr::   Constraints implied by a slot's type.
* Ref.Stat.Stmt::               Program execution as sequences of statements.
* Ref.Stat.Stmt.Point::         Inter-statement positions of logical judgments.
* Ref.Stat.Stmt.Cfg::           The control flow graph formed by statements.
* Ref.Stat.Stmt.Typestate::     Constraints that hold at points.
* Ref.Stat.Stmt.Cond::          Constraints required and implied by a statement.
* Ref.Stat.Stmt.Assert::        Explicit manipulation of typestate.

@c nb: language needs ``be'' (become) to explicitly say when you want
@c local dtors to run.  ``ret'' (return) means ``after expr'', ``be''
@c means ``before expr''. It is also required for algorithmic
@c correctness in a variety of patterns; since there are
@c call-expressions that cannot be tail-calling (such as those that
@c pass aliases to locals) it is better to require the programmer to
@c signal their intent; we can then check and complain if their intent
@c cannot be satisfied.
@c
@c you can remove this note, but do not remove ``be'' from the language.
@c
@c Hmm, now I am not sure about that: you can always insist that
@c ret-calls *mean* tail calls and when they cannot be satisfied as
@c such, you just split the ret statement from the call-statement or
@c call-expr line. Minimality argues for this. But no, this means a user
@c may need a tail-call and (stupidly) write a non-tail call, leaving
@c the splitting to discovery during debugging. Not good. Keep ``be''.

* Ref.Stmt.Be::                 Statement for stopping and executing a tail call.
* Ref.Stmt.Ret::                Statement for stopping and producing a value.
* Ref.Stmt.Put::                Statement for pausing and producing a value.
* Ref.Stmt.Fail::               Statement for nonlocal control transfer during failure.
* Ref.Stmt.Log::                Statement for logging values to diagnostic buffers.
* Ref.Stmt.While::              Statement for simple conditional looping.
* Ref.Stmt.For::                Statement for complex conditional looping.
* Ref.Stmt.If::                 Statement for simple conditional branching.
* Ref.Stmt.Alt::                Statement for complex conditional branching.
* Ref.Stmt.Prove::              Statement for static assertion of typestate.
* Ref.Stmt.Check::              Statement for dynamic assertion of typestate.
* Ref.Stmt.IfCheck::            Statement for dynamic testing of typestate.

@c note that ``prove'' is probably un-necessary. If you are going to
@c *need* to acquire a type-state p(X,Y,Z) in order to verify a
@c statement, and it can be acquired purely using static predicates,
@c surely the typestate system can check the inputs to the static
@c predicate p(...) and chain backwards into the existing prestate?
@c This should not be a problem.
@c
@c I suppose the key to 'prove' is error reporting: you can 'prove'
@c something at a particular point in the program even if you are not
@c sure how you're intending to use it. Might otherwise find it hard
@c to understand the error messages.
@c
@c FIXME: make sure you *have* a way of declaring static
@c predicates. It's simple, you just use an equals sign: pred
@c foo(a,b,c) = bar(a,b), baz(b,c);

@end menu


@node    Reference
@chapter Reference

@node    Ref.Type
@section Ref.Type

Every slot and value in a Rust program has a type. The @dfn{type} of a
@emph{value} defines the interpretation of the memory holding it. The
type of a @emph{slot} may also include constraints, @xref{Ref.Constr}.


@node    Ref.Type.Any
@section Ref.Type.Any

The type @code{any} is the union of all possible Rust types. A value
of type @code{any} is represented in memory as a pair consisting of an
exterior value of some non-@code{any} type @var{T} and a reflection
of the type @var{T}.

Values of type @code{any} can used in an @code{alt type} statement, in
which the reflection is used to select a block corresponding to a
particular type extraction. @xref{Ref.Stmt.Alt}.


@node    Ref.Type.Prim
@section Ref.Type.Prim

The primitive types are the following:

@itemize
@item
The type @code{nil}, having the single value @code{nil}.
@item
The boolean type @code{bool} with values @code{true} and @code{false}.
@item
The unsigned two's complement word types @code{u8}, @code{u16},
@code{u32} and @code{u64}, with values drawn from the integer
intervals @math{[0,(2^8)-1)]}, @math{[0,(2^16)-1)]},
@math{[0,(2^32)-1)]} and @math{[0,(2^64)-1)]} respectively.
@item
The signed two's complement word types @code{s8}, @code{s16}, @code{s32} and @code{s64},
with values drawn from the integer
intervals @math{[-(2^7),(2^7)-1)]}, @math{[-(2^15),(2^15)-1)]},
@math{[-(2^31),(2^31)-1)]} and @math{[-(2^63),(2^63)-1)]} respectively.
@item
The IEEE 754 double-precision floating point type @code{f64}.
@end itemize

In addition to these types, any symbols consisting of a single
lowercase letter in the ASCII range @code{a-z} followed by a sequence
of 1 or more decimal digits is reserved as a future primitive type in
a later version of the Rust language.

@node    Ref.Type.Int
@section Ref.Type.Int

Unlike many C-family languages, in Rust the type @code{int} is not
defined as a fixed-size machine word type. Instead, it is an arbitrary
precision type that fits in a machine word @emph{when possible} and
transparently expands to a boxed ``big integer'' allocated in the
runtime heap when it overflows or underflows outside of the range of a
machine word.

A rust @code{int} grows to accommodate extra binary digits as they are
needed, by taking extra memory from the dynamic memory pool available
to each rust process, and should only exhaust its range due to memory
exhaustion.

@node    Ref.Type.Text
@section Ref.Type.Text

The types @code{char} and @code{str} hold textual data.

A value of type @code{char} is a Unicode character, represented as a
32-bit unsigned word holding a UCS-4 codepoint.

A value of type @code{str} is a Unicode string, represented as a
vector of 8-bit unsigned words holding a UTF-8 codepoints.

@node    Ref.Type.Rec
@section Ref.Type.Rec

The record type-constructor @code{rec} forms new heterogeneous product
types. It is analogous to the @code{struct} type-constructor in
C. Fields of a @code{rec} type are accessed by name and are arranged
in memory in the order specified by the @code{rec} type.

An example of a @code{rec} type and its use:
@example
type point = rec(int x, int y);
let point p = rec(x=10, y=11);
let int px = p.x;
@end example

@node    Ref.Type.Vec
@section Ref.Type.Vec

The vector type-constructor @code{vec} represents a homogeneous,
variable-size array of values. Vectors automatically resize to
accommodate the addition or removal of elements. Elements can be
accessed by numeric index, but can be appended or removed only at the
ends: the range of initialized values in a vector is continuous from
index 0 to the maximum indexable element.

And example of a @code{vec} type and its use:
@example
let vec[int] v = vec(7, 5, 3);
let int i = v.(2);
@end example

@node    Ref.Type.Alt
@section Ref.Type.Alt

The @code{alt} type-constructor forms new heterogeneous
disjoint sum types. It is analogous to the @code{data} type-constructor
in ML. An @code{alt} consists of a number of @code{variants}, each of
which is independently named and takes an optional tuple of arguments.

An example of an @code{alt} type and its use:
@example
type animal = alt(dog, cat);
let animal a = dog;
a = cat;
@end example

An example of a @emph{recursive} @code{alt} type and its use:
@example
type list[T] = alt[T](empty,
                      cons(T, @list[T]));
let list[int] a = cons(7, cons(13, empty));
@end example


@node    Ref.Type.Fn
@section Ref.Type.Fn

The function type-constructor @code{fn} forms new function types. A
function type consists of an optional protocol, an input type, an
output type, and a set of flags indicating special characteristics of
the function.

If a function type has no protocol, it describes functions that only
return a value, and do not put any value. @xref{Ref.Stmt.Put}.

If a function type has a protocol, it describes functions that put
some number of values before returning. The protocol describes the
@emph{number} of values that the function will put during its
execution. Protocols are indicated by a variant of the @code{fn}
keyword, as follows:

@itemize
@item
@code{fn?} indicates a function that will put either 0 or 1 value, then return.
@item
@code{fn!} indicates a function that will put exactly 1 value, then return.
@item
@code{fn*} indicates a function that will put 0 or more values, then return.
@item
@code{fn+} indicates a function that will put 1 or more values, then return.
@end itemize

If a function has a protocol, the output type is the type of value
that the function will put. If a function has no protocol, the output
type is the type of value the function will return.

An example of a simple @code{fn} type:
@example
fn add(int x, int y) -> int {
  ret x + y;
}

let int x = add(5,7);

type binop = fn(int,int) -> int;
let binop bo = add;
x = bo(5,7);
@end example

A function with a protocol can only be called in the header of a
matching @code{for} loop, for example a @code{fn+} function can only
be called from a @code{for+} loop header.

An example of a @code{fn} type with a protocol:
@example
fn* range(int lo, int hi) -> int {
  let int i = lo;
  while (i < hi) {
    put i;
    i = i + 1;
  }
}

let int sum = 0;
for* (int x = range(0,100)) {
    sum = sum + x;
}
@end example

A complex example of protocols, local functions and closures:
@example
type expand[A,B] = fn*(A) -> B;
fn compose[A,B,C](expand[A,B] ab, expand[B,C] bc) -> expand[A,C] {
   fn* composed(A a) -> C {
     for* (B b = ab(a)) {
       put* bc(b);
     }
   }
   ret composed;
}
@end example



* Ref.Type.Fn::                 Subroutines and scoped coroutine types.
* Ref.Type.Port::               Unique inter-process message-receipt endpoints.
* Ref.Type.Chan::               Copyable inter-process message-sending capabilities.
* Ref.Type.Proc::               General coroutine-instance types.
* Ref.Type.Prog::               General coroutine-description types.
* Ref.Type.Mod::                Units of information hiding.
* Ref.Type.Type::               Types describing types.
* Ref.Type.Quote::              Types describing source code.


@c ############################################################
@c end main body of nodes
@c ############################################################

@node Index

@printindex cp

@bye
