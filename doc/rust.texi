\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename rust.info
@settitle Rust Documentation
@setchapternewpage odd
@c %**end of header

@syncodeindex fn cp

@ifinfo
This manual is for the ``Rust'' programming language.

Copyright 2006 Graydon Hoare

All rights reserved

Licensed to the public under the terms of the GNU GPL (>= 2.0).
See the file COPYING for details
@end ifinfo

@dircategory Programming
@direntry
* rust: (rust).         Rust programming language
@end direntry

@titlepage
@title Rust
@subtitle A general-purpose programming language
@author Graydon Hoare

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2006 Graydon Hoare
All rights reserved
Licensed to the public under the terms of the GNU GPL (>= 2.0).
See the file COPYING for details
@end titlepage

@ifnottex
@node Top
@top Top

Rust Documentation

Rust is a general-purpose programming language. It supports
imperative-procedural, concurrent-actor and pure-functional
styles. Rust also supports generic programming and metaprogramming, in
both static and dynamic forms.

@end ifnottex

@menu
* Introduction::               Background, intentions, relationships to other languages
* Lexicon::                    The basic terms used when discussing Rust
* Artifacts::                  A catalogue of the syntactic forms and their meanings
@end menu

@ifnottex
Complete table of contents
@end ifnottex

@contents

@node    Introduction
@chapter Introduction

@quotation
  It should be easy to say what you want to happen, and just as easy
  to say what you want to @emph{not happen}.
@end quotation

Rust is a ``curly-brace'' block-structured language; it visually
resembles the Algol / C family, but differs significantly in syntactic
and semantic details.

Rust's semantics are a mixture of elements found in Ada, Mesa, ML, CLU
and Hermes. It can most readily be considered a descendent of Hermes,
though there is no formal relationship.

The language design pursues the following goals:

@itemize
@item Error isolation, detection and prevention.
@item Clarity and precision of expression.
@item Implementation simplicity.
@item Runtime efficiency.
@end itemize

In pursuit of these goals, some common language features were
rejected. While not unique in rejecting these features -- some similar
rejections are made in the ancestral languages noted above -- the
informed reader should keep in mind that such rejections are usually
@emph{intentional}. An uncommon technique does not necessariliy arise
from ignorance of the alternative. This manual may provide discussion
or footnotes for additional rationale, when notable cases arise.

Four characteristics of Rust's design motivate most of the rejected
features.

First, Rust occasionally strays from the standard language-design
principles of @i{minimality} and @i{orthogonality}. Rust is
unapologetically a medium-sized language; there are many languages
smaller and simpler. Some Rust constructs are only useful in
particular ``safe'' or ``efficient'' combinations. Other constructs
are conspicuously duplicated -- with important specializations for
different cases -- due to concerns for safety, clarity or speed. 

Second, while Rust can probably be classified as a ``static language''
-- owing to the presence of a strong static type system and a certain
amount of static reasoning about storage and lifecycle -- it also
resists the habit many ``static languages'' have of throwing out all
information and language-tool functionality after compile time. Rust's
dynamic semantics are intended to support many of the useful features
of ``dynamic language'' environments such as reflective debugging,
live code generation, ``hot'' code replacement, heterogeneous
collections and latent-typed generic functions.

Third, Rust rejects a family of features that stem from a particular
interpretation of the Object Orientation paradigm, and that have come
to be ``canonical'' in mainstream (non-academic) language
designs. Features such as code-inheritence, ubiquitous dynamic
binding, cyclical memory graphs, pointer-rich data structures, and
shared-visibility concurrency are all avoided in Rust. The legitimate
motivations for these features are addressed via other means.

Fourth, Rust rejects models of computation that require expensive
runtime mechanisms to support, or appear to be ``hiding'' important
aspects of real computing machinery behind too much abstraction. Of
course this distinction is aesthetic and subjective.  To be specific:
Rust intentionally omits lazy or implicit evaluation, implicit data
parallelism, software transactional memory and tracing garbage
collection. Rust presents a model of computation deemed ``most
obvious'' on Von Neumann machines: linear memory segments with
explicit owners, explicit co-routines and communication primitives,
and strict, sequential execution within primary routines. Parallelism
is supported -- indeed it is ubiquitous in Rust's abstractions -- but
only in explicit terms.


@node    Lexicon
@chapter Lexicon

Rust is defined in terms that may be familiar to readers experienced
with other programming languages. Nevertheless it is important to
clarify the meaning of certain terms which are used in precise, and
occasionally unusual ways within the language definition.

In the following sections, some terms are used but not defined. In
some cases example code is given with portions unexplained. The
purpose of the following sections is to provide suggestive intuitions
about major concepts in Rust. Precise definitions are provided in
later chapters.


@node    Programs and Processes
@section Programs and Processes

Rust borrows operating system terminology in order to differentiate
two important artifacts: @i{programs} and @i{processes}. A program is
the inert, non-executing form of rust code. A process is the
instantiated, ``live'', possibly-executing form of rust code. A
program can be executed, a process @emph{is the executing state} of a
program; every process has a program that it is currently executing.
We will use these terms precisely and non-interchangeably.

Programs and processes are Rust's fundamental units of encapsulation,
state, behavior and concurrency. A collection of rust code may define
many distinct programs, and each program can be instantiated into many
distinct processes. Processes execute functions, exchange messages
with other processes, and may spawn further sub-processes. Processes
may execute concurrently, or may have their execution interleaved.

There is some similarity between the OOP terms ``class'' and
``object'' and the Rust terms ``program'' and ``process''. In OOP,
classes are instantiated into objects; in Rust, programs are
instantiated into processes. This symmetry may help your intuition,
but it is not sufficient to motivate us to adopt the OOP terminology:
there are sufficient differences between Rust's process model and OOP
that such terminology would cause confusion. Rust does not define
anything called a ``class'' or an ``object''.

When we wish to speak of operating system processes we will use the
term ``operating system processes'' or ``OS processes''; otherwise the
word ``process'' refers to a rust process. Rust processes are
considerably smaller and more lightweight than operating system
processes: a single OS process running Rust code may contain thousands
or millions of Rust processes.

We may sometimes speak of ``a program doing something''. This is a
short-hand way of saying that ``a process that is an instance of the
program would do something''. Programs themselves do not @emph{do}
anything; they are inert values, pieces of text. The difference is
important to maintain in your mind, as Rust defines very different
operations on programs and processes. Programs may be parsed, printed,
copied, transmitted, compiled, typechecked or executed. Processes may
be started, paused, resumed, stopped, or queried for various execution
parameters.

@node    Values and Slots
@section Values and Slots

Rust programs manipulate values. A Rust @i{value} is any information
that can be denoted by a Rust term. Values occupy memory: every value
consumes a certain number of bits. Numbers are values, as are strings,
records, vectors, programs, processes, and many other things
besides.

Some values have slots. A @i{slot} is a named set of bits
@emph{inside} a value that can @emph{refer to} another value, either
directly by containing the referent, or indirectly by storing a memory
address of the referent. Variables within a module or stack frame are
slots, as are the fields within records or the components of tuples
and vectors.

@node    Types, Forms, Predicates and Constraints
@section Types, Forms, Predicates and Constraints

Every Rust slot has a type. A @i{type} is a static description of a
subset of all the possible values. A type has two parts: 

@itemize
@item the @i{form} of the type
@item the @i{constraint} of the type
@end itemize

The form of a type describes how many bits the type occupies in
memory, and how to interpret those bits. Forms are built from a set of
fundamental ``machine-level'' forms such as ``number'' or
``character'', and a set of form constructors such as ``record'',
``function'', ``tuple'', or ``vector''. For example, this code:

@example
type coord3d = (int, int, int);

type buf = vec[byte];

type employee = rec @{ 
                      string name; 
                      dec salary; 
                    @};
@end example

introduces 3 new types: one with a tuple form, one with a vector form,
and one with a record form. 

The @i{constraint} of a type is a set of zero or more predicates. A
@i{predicate} is a pure boolean function. We say that a predicate
``holds'' over a value if the predicate returns @code{true} when
applied to the value, otherwise we say that the predicate ``does not
hold'' over the value. For example, this code:

@example
pred is_even(int x) @{
  return x % 2 == 0;
@}

pred is_nonzero(int x) @{
  return x != 0;
@}
@end example

introduces 2 new predicates: one that tests for even-ness and one that
tests for nonzero-ness. Predicates and types can be bundled together
into a type definition. For example, this code:

@example
type even_nonzero_int = int : is_even(*), is_nonzero(*);
@end example

defines a new name for the type of integers that are even and nonzero.

A slot can refer to a value if and only if the value has the same form
as the slot's type, and the constraints in the slot's type all hold
over the value. For example, this code:

@example
int foo : is_even(*), is_nonzero(*);
@end example

introduces an integer slot that is constrained to be even and
nonzero. Using our earlier definition, it could be equivalently
written as this code:

@example
even_nonzero_int foo;
@end example

@node    Points, Typestates and Assertions
@section Points, Typestates and Assertions

Rust borrows terminology from the Hermes programming language to
describe a particular static error-checking technique. This technique
is called @i{typestate checking}. To define typestates, we must define
points: a @i{point} exists before or after any statement in a Rust
program. For example, this code:

@example
 s = "hello, world";
 print(s);
@end example

Consists of two statements and three points: 

@itemize
@item the point before the first statement
@item the point between the two statements
@item the point after the second statement
@end itemize

Every point in a rust program has a static typestate, just as every
slot has a static type. A @i{typestate} is a set of predicates; the
typestate of a point is the set of predicates that must hold at that
point. The predicates in a typestate can refer to @emph{any slots}
visible at the typestate's point. The static @i{typestate checking
algorithm} ensures that program control only flows through points that
contain predicates known to hold.

Because many predicates are not computable statically -- they depend
on the dynamic state of values -- programmers must occasionally insert
assertions. An @i{assertion} is simply a statement that calls a
predicate with the built-in operator @code{assert}, which prevents
execution from proceeding if the predicate does not hold. Thus the
typestate checking algorithm inserts an assertion's predicate into the
typestate of the point after the assertion. For example, this code:

@example
int x;
int y : is_even(*);
x = foo();
y = x;
@end example

consists of two slots -- @code{x} and @code{y} -- and two statements,
thus three points. The first statement calls @code{foo} and assigns
its result to @code{x}. The second statement assigns @code{x} to
@code{y}. This code is @emph{erroneous} according to the typestate
checking algorithm: the point before the second statement does not 
contain the @code{is_even(x)} predicate, so the assignment would violate
the constraint on @code{y}.

The code can be corrected using an assertion. This corrected code:

@example
int x;
int y : is_even(*);
x = foo();
assert is_even(x);
y = x;
@end example

Consists of three statements and four points. At the first two points,
the typestate does not contain the @code{is_even(x)} predicate. At the
third point -- the point @emph{after} the assertion -- the typestate
@emph{does} contain the @code{is_even(x)} predicate. So the third
statement is now legal: if the third statement ever executes, it will
assign a value @emph{statically} known to satisfy the constraint
placed on the slot @code{y}.

It is crucial to understand that the typestate of the third point is a
@emph{static} fact about @emph{static} entities -- slots, points and
predicates -- even though the runtime behavior will vary depending on
the runtime value of @code{x}. If the predicate fails at runtime,
control will not proceed past the @code{assert} statement, and the
assignment will never be made.

To reiterate: the typestate checking algorithm is not responsible for
statically evaluating predicates. It simply calculates the predicates
that are @emph{known to hold} at each point -- if control ever reaches
the point -- and reports on mismatches between the predicates known to
hold at a point and the predicates @emph{required} by slot constraints.

Typestates encode requirements for complicated dynamic assertions in
the language's static checking system. This makes it easier to rule
out erroneous inputs to functions and programs that you write:
function parameters and return values are slots just like variables,
and can be annotated with constraints. In this respect typestates are
similar to a form of ``design by contract'', except that the typestate
checking algorithm examines the static control-flow graph and
minimizes the number of times an expensive assertion must be
(re-)checked.


@node    Artifacts
@chapter Artifacts

@page
@node    Structural artifacts
@section Structural artifacts

A collection of Rust source code can be thought of @emph{structurally}
as a set of artifacts that logically @i{contain} one another. There
are four kinds of artifacts in this view: @i{crates}, @i{modules},
@i{slots} and @i{values}.

@subsection Crate

A @dfn{crate} is a unit of configuration, linkage and distribution
for Rust code. Crates logically contain modules. Crates have
``unfriendly'' names -- names that look like ugly and meaningless
numbers -- but these names are ``universally unique''.

The source form of a crate is a @dfn{crate file}, which is a
text file ending in @code{.rc}. The compiled form of a crate is a
binary dynamic-link library, such as an ELF or PE library (ending in
@code{.so} or @code{.dll} respectively).

Crate files contain a description of a tree of modules, and
instructions about how to compile the crate. The Rust compiler
operates on crate files. Crate files may reference other
crates, in order to import qualified module names from them, but
the reference graph of crate files is a DAG.

@subsection Modules

A @dfn{module} is a unit of @emph{name organization} within a
crate. The tree of modules in a crate corresponds 1:1 with a tree of
directories and files in a filesystem. Thus there are two kinds of
modules: @dfn{directory modules} and @dfn{source modules}. A directory
module contains sub-modules. A source module contains values.

Source modules, also called @dfn{source files}, are files ending
in @code{.rs}. These files contain code that defines slots.

Modules are arranged in a human-friendly namespace within a crate.
It is the responsibility of a team of programmers working on a
crate to ensure that their module names to not collide, inside the
crate. Module names can be reused in different crates,
however; the names in one crate are unrelated to the names in
another crate.

Modules contain slots, and some of those slots point to values. There
are many types of value; the complete list is provided in the next
section. For now it is sufficient to note that most Rust code is
concerned with manipulating values. Much more than the portion of Rust
code that relates to modules and crates.

@subsection Slots

Finally, within modules there are @i{slots}. A @dfn{slot} is a named
memory location that can refer to a value. Some values will contain
more slots, that in turn may refer to more values. Each source module
defines a set of slots that are the ``top level'' slots of the
module. Further slots exist in many contexts:

@itemize
@item Variables within functions, ports and predicates.
@item Fields within records, alternatives and programs.
@item Components of vectors.
@end itemize


@page
@node    Values
@section Values

Rust defines a wide variety of types and type constructors.

@menu
* Primitive types::           Machine-level values.
* Dynamic types::             Latently-typed values.
* Arithmetic types::          High-precision numbers.
* Textual types::             Strings and characters.
* Records::                   Fixed products of heterogeneous types.
* Vectors::                   Dynamic products of homogeneous types.
* Alternatives::              Sums of heterogeneous types.
* Functions::                 Subroutines and scoped coroutines.
* Predicates::                Pure functions involved in typestates.
* Programs::                  General coroutines.
* Processes::                 Instances of programs.
* Ports::                     Inter-process message inputs.
* Channels::                  Weak capabilities to send messages to ports.
* Types::                     Values representing types.
* Quotations::                Values representing source code.
@end menu

@node       Primitive values
@subsection Primitive values

@node       Dynamic values
@subsection Dynamic values

@node       Arithmetic values
@subsection Arithmetic values

The types of arithmetic value are:

@itemize
@item @code{nat}, the type of arbitrary-precision naturals.
@item @code{int}, the type of arbitrary-precision integers.
@item @code{rat}, the type of arbitrary-precision rationals.
@end itemize

All these types are represented internally as alternatives; on N-bit
systems, typically, N-1-bit integral values of any of these types are
stored as single machine words.

@node       Textual values
@subsection Textual values

The types of textual value are:

@itemize
@item @code{char}, the type of unicode codepoints, as @code{u32} values.
@item @code{str}, the type of unicode strings, equal to @code{vec[char]}.
@item @code{strenc.utf8}, a @code{vec[u8] : strenc.is_utf8(*)}, the type of unicode strings encoded into UTF-8.
@item @code{strenc.*}, various other character encodings.
@end itemize

It should be emphasized that the primary string type should not be
blindly memory-copied into an external buffer, as it will produce a
sequence of numbers in the host byte order, and not necessarily equal
to a particular UTF-8 or UCS-4 encoding. When externalizing a string,
care should be taken to select an appropriate encoding from the
standard @code{enc.*} module.

@node       Records
@subsection Records

The @code{rec} type introduces new record types that have named fields,
similar to the @code{struct} types of C.

Anonymous record literals and record types are denoted with the
keyword @code{rec}. The fields of a record are defined, as a sequence
of slot declarations within braces, similar to the slot declarations
in a stack frame.

Record fields can carry ``inline'' typestate constraints, similar to
slots in a stack frame. Record types can also carry formal typestates
relating to the record as a whole, or to some combination of its
fields.

@node       Vectors
@subsection Vectors

Vectors are variable size, homogeneous, 1-dimensional containers. 

Vectors are parametric types, denoted with the keyword
@code{vec}. Anonymous vector literals and vector types containing type
@code{T} are denoted as @code{vec[T]}.

A vector has two associated sizes: one representing the vector's
allocated size, and one representing a bound on the initialized range
of the vector. Within the initialized-range bound, all elements carry
the @code{init} predicate. 

Vectors dynamically resize using doubling and halving operations that
amortize byte-copying costs to a constant factor per element.

Because vectors automatically resize and byte-copy their contents,
they represent a form of transplantation (see @ref{Value
transplanting}), therefore vectors cannot contain directly limited
values (see @ref{Limitation}). For values with indirectly limited type
@code{T}, vectors of @code{T} are supported provided, but the vector
must be declared as @code{lim vec[T]}, as such a vector type itself is
indirectly limited.

Because the @code{init} predicate is managed homogeneously over the
initialized range of the vector, not per-element, vectors cannot have
individual elements deinitialized. Instead, the following operations
are defined:

@itemize
@item Elements can be swapped inside the vector.
@item An element of the appropriate type can be appended to the vector.
@item A vector of the same element type can be appended to the vector.
@item The vector can be truncated to any size smaller than its current size.
@item An element of the vector can be swapped with an external, initialized value.
@end itemize

Vectors can have an associated formal typestate that applies to every
element in the vector, or to the vector as a whole.

@node       Alternatives
@subsection Alternatives

Alternatives are structures that contain, at any given point, exactly
one of an explicitly enumerated set of possible values.  They are
similar to the disjoint sum types of ML, and can be seen as a ``safe''
version of @code{union} types in C.

Alternatives are denoted with the @code{alt} keyword. The possible
values of the alternative are called @i{cases}, and the cases are
denoted with unique identifiers, that act as labels.

The space consumed by an N-alternative has two components:

@itemize
@item The space for the cases, which is the maximum space required 
for any of the cases. This space is used regardless of case.
@item The space for the discriminant field, which is @code{ceil(log_2(N))}
bits.
@end itemize

If the space consumed by an alternative can fit inside a single word,
Rust is obliged to store it this way. In particular, on a machine that
effectively ``does not use'' K low bits of its pointers (due to
alignment restrictions), those K low bits can be used to encode a
@code{2^K}-case alternative. Every implementation of Rust must perform
this optimization.

@node       Functions
@subsection Functions

Functions model subroutines as well as 4 limited, stack-scoped forms
of coroutine. Functions are given either one or two points in their
caller's frame to return and/or yield to. A function @i{returns} a
value if it moves a value into the caller-allocated return slot,
deallocates its frame and jumps to the return point. A function
@i{yields} a value if it moves a value into the caller-allocated yield
slot, moves the current program counter into the caller-allocated
resume slot, jumps to the yield point and @emph{does not} deallocate
its frame. If a function yields, the caller may @i{resume} the
function and permit it to return of its own accord, or may
@i{terminate} the function by jumping to the function's epilogue and
deallocating its frame. Every function eventually executes its
epilogue, either caused by a return, an exception, or caller
termination.

Each argument to a function occupies 1 word or less. If the form of an
argument is larger than a word, an address is placed in the argument
slot. If the form of an argument is equal to or smaller than a word,
the argument value is copied or moved into the argument slot directly.

The arguments to a function implicitly occupy a tuple, though it is a
special tuple that contains only immediate or dependent slots. The
argument tuple implicitly carries the @code{all} predicate; thus each
parameter carries the @code{init} predicate in the callee. Similarly
the yield and return slots allocated in the caller carry the
@code{init} predicate when visible (after the jump of a yield or
return). The yield slot is either immediate or dependent; the return
slot is either immediate, interior or exterior.

An un-annotated function parameter implies that the associated
argument is copied into the argument tuple during a call, though in
the case of superword-sized arguments such copies are made lazily in
the callee if and only if the callee writes to the argument; read-only
use of an argument simply loads through the provided address without
making a copy of the argument. Superword-sized ``copy'' arguments and
yields are @emph{the} canonical case of a dependent slot (see
@ref{Slot modes}).

A function parameter of type @code{T} can be annotated in two ways:

@itemize
@item @code{T-}, which means ``move in''
@item @code{T=}, which means ``move in and out''
@end itemize

A ``move in'' parameter is moved from its caller frame into its callee
frame: once control enters the callee, the slot holding the moved
parameter in the caller has lost the @code{init} predicate.

A ``move in and out'' parameter is like a ``move in'' parameter,
except that the value in the callee's parameter slot is moved out
again, back to the caller's frame, when the function returns.

There is no parameter annotation that implies ``move out'' without
``move in'': to move a value out of a function, simply return or yield
the value. Return values always use ``move semantics'' since the slot
containing the return value is only visible up until the point of
return, not beyond. Yield values use ``copy semantics'' by default,
via an immediate or dependent yield slot; the yield type expression on
a yielding function signature can be annotated with the @code{+}
suffix to get ``move'' semantics on the yield value.

Parameter types, return types and yield types can all be annotated as
exterior using the @code{^} prefix, just like all slot
declarations. See @ref{Slot modes}.

Functions are required to support proper tail-calls.

Functions may be pure. A pure function performs no communication
tasks: it does not send on any channel, nor does it spawn or otherwise
interact with a process type. See @ref{Purity}.

In addition to the basic call/return protocol for functions, which is
declared with the @code{func} keyword, 4 types of scoped coroutine are
supported, that may yield before they return:

@itemize
@item @code{func!} denotes a function that yields once.
@item @code{func?} denotes a function that yields 0 or 1 times.
@item @code{func*} denotes a function that yields 0 or more times.
@item @code{func+} denotes a function that yields 1 or more times.
@end itemize

Scoped coroutines are also required to support proper
tail-@emph{yields}. A tail-yield occurs when a primary coroutine
invokes a sub-coroutine with a construct that yield every value
yielded by the sub-coroutine. Then the primary coroutine passes its
caller's yield address to the sub-coroutine, for direct yielding
between the sub-coroutine and caller. When such a tail-yield happens
in tail-call position (the last statement of a coroutine before a
return), the coroutine is requried to replace its stack frame with the
frame of the sub-coroutine, as with a return-based tail call.

The 4 types of coroutine combine with 4 specific caller-side control
structures to 4 important non-copying calling patterns. Each is
useful, and interacts in a precise manner with the typestate checking
algorithm. One way to picture the differences is to picture the
control-flow graph in the caller: when binding a yielded value inside
a temporary control block, the caller's control graph has either none,
one, or both of a ``bypass edge'' (if no yield occurs) and a ``back
edge'' (if more than one yield occurs). Combining these possibilities
produces 4 possible scenarios: neither (@code{func!}), bypass-no-back
(@code{func?}), back-no-bypass (@code{func+}) and both (@code{func*}).

A function declaration also defines an associated @i{call record} that
represents the parameter-passing requirements of the function in a way
that is accessible to introspection or polymorphic invocation. This
record contains an @i{arguments tuple}, a @i{return value slot}, and
possibly a @i{yield value slot}. Given a call record, there are 5
polymorphic @i{apply} operators that will invoke a function of
compatible type. Invocation involves forming a call frame full of
immediate or dependent slots for each value in the call record's
argument tuple, copying or moving values into those slots, then
running the callee. Yields and returns from the function are
tail-yielded or tail-returned back to the caller of the apply
operator. This permits writing polymorphic call-proxying code while
keeping the standard case efficient.


@node       Predicates
@subsection Predicates

Predicates are boolean pure functions that connect runtime values to
the typestate system. A typestate is a set of predicates applied to a
set of slots at a particular point; introducing a new predicate
thereby enlarges the set of possible typestates. See @ref{Typestates}.

Predicates can be asserted with the keyword @code{assert}. The
poststate of a statement @code{assert p(q,r)} is the union of the
prestate with the predicate @code{p} applied to slots @code{q} and
@code{r}.

@node       Programs
@subsection Programs

@node       Processes
@subsection Processes

@node       Ports
@subsection Ports

@node       Channels
@subsection Channels

@node       Types
@subsection Types

@node       Quotations
@subsection Quotations


@page
@node    Type system
@section Type system


@node       Value and slot types
@subsection Value and slot types

Every value has a unique form.

Every slot has a unique type.

If a slot @var{S} references a value @var{V}, type of @var{S} has a
form that is identical to the form of @var{V}, and the type of @var{S}
has a constraint that holds over @var{V}. Of course @var{S} may be
further constrained by other predicates at its point of declaration,
but those predicates @emph{add} to the constraint in the type of
@var{S}. They do not replace it.


@node       Limitation
@subsection Limitation

Some types are @i{limited}. A type @var{T} is @dfn{limited} iff either of
these conditions hold:

@itemize
@item The type @var{T} contains a limited slot.
@item The type @var{T} is a process type.
@end itemize

Limited values cannot be copied or transmitted. See @ref{Memory model}
for the definitions of copying and transmission.

A type that is a process type is called @dfn{directly limited}. A type
that simply contains a limited slot is called @dfn{indirectly
limited}. 

Limitation ``infects'' the structure that contains it; any type that
is indirectly limited must be declared as such with the keyword
@code{lim}.


@node       Purity
@subsection Purity

Functions may be @i{pure} or @i{impure}. A
function @var{S} is @dfn{impure} iff any of these conditions hold:

@itemize
@item The function @var{S} is @emph{not} declared as @code{pure}
@item The function @var{S} calls any impure functions.
@item The function @var{S} calls any channels.
@end itemize

Purity exists as a concept in Rust for two reasons:

@itemize
@item As a basic aid to code comprehension. Pure functions are easier
to reason about, so programmers may wish to ensure that portions of
their work are pure.
@item Predicates are effectively pure boolean functions. Predicates
are @emph{required} to be pure for the typestate system to function
correctly. Since purity is required for predicates, extending the
concept of purity to functions and iterators permits predicates to
call them safely. Otherwise predicates would have to be
self-contained.
@end itemize
    

@page
@node    Typestates
@section Typestates

Every block of statements containing expressions maps to a block of
primitive statements in a normal form. In this form, every statement
is logically one of:

@itemize 
@item A conditional jump statement.
@item A move or copy statement between two slots.
@item An allocation or deallocation statement.
@item Invocation of a function, iterator, or channel with a ``call message''.
@end itemize

A @dfn{point} is defined as the boundary between two normalized
sequential statements.  Every point in a normalized block has a
@i{typestate}. Two typestates are therefore defined for each
normalized statement: 

@itemize
@item The @dfn{prestate}, that precedes the statement.
@item The @dfn{poststate}, that follows the statement.
@end itemize

A @dfn{typestate} is formally a set of @var{N}-ary boolean predicates
over visible slots.

Typestates form a semilattice ordered by subset-inclusion: @var{X} <
@var{Y} means @var{X} is a subset of @var{Y}, and the semilattice
``join'' operation is ``set intersection''.

When @var{K} statements lead to a single point, the point's typestate
is the pairwise join of the @var{K} poststates of preceding
statements.

Predicates are declared with @code{pred}, and have names and
signatures similar to functions. The body of a predicate is
syntactically a pure boolean function. The signature of a predicate
cannot include the keyword @code{pure} or the @code{bool} return type;
these are implied and non-optional.


@node       Asserting predicates
@subsection Asserting predicates

The @code{assert} statement either adds the asserted predicate to its
poststate, or else fails, raising an exception. If a predicate is
declared as @code{auto}, assertions are inserted automatically some
contexts. 

Specifically: every operation (statement type) has a set of
preconditions, formulated as predicates. If a precondition names a
predicate that is not present in the statement's prestate, one of two
cases occurs:

@itemize
@item If the missing predicates are all @code{auto} and all the 
preconditions of the missing @code{auto}-predicates are met, the
compiler may insert assertions for each missing predicate.
@item Otherwise the condition is a compile-time error.
@end itemize

@node       Dropping predicates
@subsection Dropping predicates

All predicates in a typestate can be @i{dropped}. To @dfn{drop} a
predicate is to remove it from the typestate at the associated
point. For a slot @var{S}, dropping the @code{init(S)} predicate may
cause memory to be released or finalizer to be run. See @ref{Memory
model} for discussion. All other predicates can be dropped without
side-effect.


@node       Predicates on moved values
@subsection Predicates on moved values

When a statement moves a value from a slot @var{A} to a slot @var{B}: 

@itemize
@item Every predicate involving @var{B} is dropped.
@item Every remaining predicate involving @var{A} has @var{B} 
substituted for @var{A}.
@end itemize


@node       Predicates on copied values
@subsection Predicates on copied values

When a statement copies a value from a slot @var{A} to a slot @var{B}: 

@itemize
@item Every predicate involving @var{B} is dropped.
@item For every remaining predicate @var{P} involving @var{A}, 
a copy of @var{P} is added to the typestate with @var{B} substituted
for @var{A}.
@end itemize


@node          Formal typestates
@subsubsection Formal typestates

When defining a type @var{T}, a typestate @var{S} can optionally be
associated with @var{T}. When present, we say that @var{S} is the
@dfn{formal typestate} of @var{T}. When a slot has a type @var{T} with
a formal typestate @var{S}, it means that all the predicates in
@var{S} are present in the typestate of every point in which the slot
is @i{visible}.

A slot becomes @dfn{visible} at the point immediately following the
statement containing its declaration, and remains visible through to
the end of the last statement in the block containing its declaration.


@node       Reflection
@subsection Reflection

Types and predicates are reflected into runtime values. Runtime values
can always be converted to type @code{dyn} or @code{lim dyn}, which
carries the type of its value (including formal typestate) along with
it.

The runtime representation of a type can be compared to the runtime
representation of another type.

To connect runtime and compile-time values, a type-switch statement
exists over @code{dyn} values; each arm of the type-switch
temporarily moves the @code{dyn}'s value into a typed slot.


@node       Type system comparison with other languages
@subsection Type system comparison with other languages

We borrow structure (but not terminology) from Ada and Hermes when
organizing the type system. In particular:

@itemize
@item A constrained type -- similar to an Ada "subtype" -- is a base type accompanied with a set of
constraints. Constraints are formulated using Hermes-style typestate
predicates rather than Ada's fixed set of constraints.
@item There is no general subtype lattice (as in OO languages). There is only
one type for each value. This is common to both languages.
@end itemize


@node       Pragmatic notes
@subsection Pragmatic notes

Constrained types do not participate in overload resolution, because
predicates can always be dropped.

If you wish to produce a new type that wraps an old type and
@emph{does} participate in overload resolution, you can use the
@code{newtype} type operator, which duplicates a type expression.

@page
@node    Memory model
@section Memory model


@node       Semantic model
@subsection Semantic model

Rust's memory model logically consists of a set of values, arranged in
a logical tree, and physical DAG. Values have 1:1 type relationship so
values may be said to be limited or not, just like types. See
@ref{Limited types} for details.

The relationships between slots and values are the edges in the memory
DAG.


@node       Initialization 
@subsection Initialization 

Every slot is either @i{initialized} or @i{empty}.

A slot @var{S} is @dfn{initialized} iff it refers to a value in the
memory DAG, otherwise @var{S} is @dfn{empty}. When the slot
@var{S} is initialized, the predicate @code{init(S)} is added to the
typestate. If the predicate @code{init(S)} is dropped, the slot
@var{S} becomes empty.


@node       Sharing
@subsection Sharing

Semantically, every slot holds a unique subtree that is not
shared. This is why we say that memory is arranged into a logical
tree.

In physical memory, some number of memory subtrees may be shared
copy-on-write (CoW). This is why we say that memory is a DAG. The
amount of sharing is specified and obligatory: exterior allocations
have reference counts stored at the beginning of their allocation, and
are reclaimed when the reference count drops to zero. Interior
allocations are reclaimed when the slot containing the allocation
becomes empty (loses the @code{init} predicate). See @ref{Allocation
modes}.


@node       Assignment
@subsection Assignment

Rust has two built-in notions of assignment. 

First, one can @dfn{move} a value between slots. Movement is
written with the operator @code{<-}; an example is @code{B <- A;}
which means "move A to B". All values can be moved. 

Second, one can @dfn{copy} a value between slots. Copying is
written with the operator @code{=}; an example is @code{B = A;}
which means "copy A to B". Limited values cannot be copied.

In both move and copy assignments, the left slot is called the
@dfn{destination} and the right slot is called the @dfn{source}.

The affect of copying and movement on typestates is described in
@ref{Predicates and assignment}. In short, predicates associated with
the destination slot are dropped, and predicates associated with the
source slot are either replaced or duplicated to refer to the
destination slot.

The @code{init} predicate models the initialization state of a slot,
and thus the presence or absence of a slot's reference to a
value. When an @code{init} predicate is dropped during an assignment,
it may thereby drop a reference to a value. This in turn may cause
either finalization -- if the value is limited and contains processes
with finalizers -- and/or storage reclamation, if the unreferenced
value was exterior-allocated (see @ref{Allocation modes}).

The behavior of a move or copy is completely defined by the typestate
transition rules in @ref{Predicates and assignment}, as well as one
additional rule: that in either @code{B = A;} or @code{B <- A}, if the
prestate has @code{init(A)} and slot @var{A} refers to value @var{V}
before the assignment, then slot @var{B} refers to value @var{V} after
the assignment.


@node       Allocation modes
@subsection Allocation modes

Values can be allocated in either an @i{exterior} or @i{interior}
mode. @dfn{Exterior allocation} typically means ``allocated on the
heap''. @dfn{Interior allocation} means that the value is allocated
within a contiguous block of memory owned by some other
value. Interior allocations are commonly made for slots in @code{rec}
and @code{vec} values, as well as slots in function and port frames.

Slots also have modes, each of which may imply that the slot's
referent has a particular allocation mode. See @ref{Slot modes}.


@node       Value transplanting
@subsection Value transplanting

When a value is moved or copied into a slot that requires an
allocation mode different from the allocation mode of the value, the
value may be @i{transplanted} during the move or
copy. @dfn{Transplanting} a value means moving or copying the value by
byte-copying it into a new location in memory. Transplanting may also
involve allocating fresh memory from the heap, if the transplant
destination is exterior.

The slot modes (see @ref{Slot modes}) ensure that directly limited
types are never transplanted.

Rust's memory model strives to minimize three things simultaneously: 

@itemize
@item The amount of value transplanting.
@item The amount of exterior allocation.
@item The amount users have to think about either of the above.
@end itemize


@node       Type size
@subsection Type size

Values consume a particular amount of memory when they are allocated.
The type of a value may, or may not, determine how much memory is
required to store a value of that type.

If a type is parametric, opaque, or forward-declared (and not yet
defined) we say that has of @dfn{indefinite size}. Otherwise we say
that the type has @dfn{definite size}. Since values and slots also
have unique types, we may refer to slots or values as having definite
or indefinite size.

Note however that under the slot modes (see @ref{Slot modes}), the
space allocated for a slot itself has definite size: slots either
contain values with definite size, or else hold addresses, which have
definite size themselves. Thus the contribution of a slot to its
containing structure's size is always definite. In other words, the
property of ``having indefinite size'' does not ``infect'' containing
structures.

If a type has definite size that is equal to or smaller than the size
of a machine word (in bits), we say that the type has @dfn{subword
size}.  All types with definite sizes larger than a machine word, as
well as types with indefinite size, are said to have @dfn{superword
size}.


@node       Slot modes
@subsection Slot modes

Slots have modes. A slot's mode determines how the slot relates to its
referent. There are four slot modes:

@itemize
@item Immediate
@item Dependent
@item Exterior
@item Interior
@end itemize

A slot is immediate iff it has subword size. The space allocated to an
immediate slot is also used to contain the value, and every copy is
effectively a ``transplant'' because there is no advantage to copying
less than the full value.

A slot is dependent iff all of the following 3 conditions hold:

@itemize 
@item The slot type has superword size
@item The slot has the @code{init} predicate everywhere it is visible
@item The slot is not written to anywhere it is visible
@end itemize

The most important cases of dependent slots are non-immediate slots
for function arguments, yields and returns, and the arms of @code{alt}
statements. Dependent slots hold addresses of either interior or
exterior values, but do @emph{not} manipulate reference counts,
deinitialize or deallocate values.

A slot is interior iff all of the following 4 conditions hold:

@itemize 
@item The slot type has definite, superword size
@item The slot type is not directly limited
@item The slot is not dependent 
@item The slot is not explicitly marked as exterior
@end itemize

Interior slots always contain their interior allocation; assignment of
an exterior value to an interior slot causes a transplant to the
interior storage. Interior slots are somewhat similar to immediate
slots, insofar as their value is stored within the memory structure
that contains the slot. Interior slots differ from immediate slots
insofar as the @emph{address} of an interior slot can be stored in a
dependent slot. The address of an immediate slot is never taken; they
are always copied or moved in full.

Exterior slots always contain the address of an exterior allocation;
assignment of an interior value to an exterior slot causes a
transplant to exterior storage.

A slot is exterior iff its declaration has been @emph{marked} as
exterior, with the slot qualifier @code{^}. By writing @code{^T} for a
slot with type @code{T}, the programmer states that the slot will
always refer to an exterior allocation.

A non-dependent slot @emph{must be} marked as exterior if either of
the following two conditions hold:

@itemize 
@item The slot type has indefinite size
@item The slot type is directly limited
@end itemize

Even outside of these cases, however, the programmer may insert
exterior annotations simply to control the ``shape'' of allocated
memory: to vary the time/space tradeoff between efficiently-allocated
interior allocations and efficiently-rearranged exterior allocations.

It should be emphasized, however, that the @code{^} qualifier does
@emph{not} produce an separately denotable concept of ``address'':
there is no mechanism for denoting or manipulating the address stored
in a reference slot, and all the type-state rules are identical for
reference and non-reference slots. 



@node Index

@printindex cp

@bye
