\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename rust.info
@settitle Rust Documentation
@setchapternewpage odd
@c %**end of header

@syncodeindex fn cp

@ifinfo
This manual is for the ``Rust'' programming language.

Copyright 2006, 2007 Graydon Hoare

All rights reserved

Licensed to the public under the terms of the GNU GPL (>= 2.0).
See the file COPYING for details
@end ifinfo

@dircategory Programming
@direntry
* rust: (rust).         Rust programming language
@end direntry

@titlepage
@title Rust
@subtitle A general-purpose programming language
@author Graydon Hoare

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2006 Graydon Hoare
All rights reserved
Licensed to the public under the terms of the GNU GPL (>= 2.0).
See the file COPYING for details
@end titlepage

@ifnottex
@node Top
@top Top

Rust Documentation

Rust is a general-purpose programming language. It supports imperative
procedural, concurrent actor and pure functional styles. Rust also
supports generic programming and metaprogramming, in both static and
dynamic forms.

@end ifnottex

@menu
* Introduction::               Background, intentions, relationships to other languages
* Lexicon::                    The basic terms used when discussing Rust
* Artifacts::                  A catalogue of the syntactic forms and their meanings
@end menu

@ifnottex
Complete table of contents
@end ifnottex

@contents

@node    Introduction
@chapter Introduction

@quotation
  It should be easy to say what you want to happen, and just as easy
  to say what you want to @emph{not happen}.
@end quotation

Rust is a ``curly-brace'' block-structured language; it visually
resembles the Algol / C family, but differs significantly in syntactic
and semantic details.

Rust's semantics are a mixture of elements found in Ada, Mesa, ML, CLU
and Hermes. It can most readily be considered a descendent of Hermes,
though there is no formal relationship.

The language design pursues the following goals:

@itemize
@item Error isolation, detection and prevention.
@item Clarity and precision of expression.
@item Implementation simplicity.
@item Runtime efficiency.
@end itemize

In pursuit of these goals, some common language features were
rejected. While not unique in rejecting these features -- some similar
rejections are made in the ancestral languages noted above -- the
informed reader should keep in mind that such rejections are usually
@emph{intentional}. An uncommon technique does not necessariliy arise
from ignorance of the alternative. This manual may provide discussion
or footnotes for additional rationale, when notable cases arise.

Four characteristics of Rust's design motivate most of the rejected
features.

First, Rust occasionally strays from the standard language-design
principles of @i{minimality} and @i{orthogonality}. Rust is
unapologetically a medium-sized language; there are many languages
smaller and simpler. Some Rust constructs are only useful in
particular ``safe'' or ``efficient'' combinations. Other constructs
are conspicuously duplicated -- with important specializations for
different cases -- due to concerns for safety, clarity or speed. 

Second, while Rust can probably be classified as a ``static language''
-- owing to the presence of a strong static type system and a certain
amount of static reasoning about storage and lifecycle -- it also
resists the habit many ``static languages'' have of throwing out all
information and language-tool functionality after compile time. Rust's
dynamic semantics are intended to support many of the useful features
of ``dynamic language'' environments such as reflective debugging,
live code generation, ``hot'' code replacement, heterogeneous
collections and latent-typed generic functions.

Third, Rust rejects a family of features that stem from a particular
interpretation of the Object Orientation paradigm, and that have come
to be ``canonical'' in mainstream (non-academic) language
designs. Features such as code-inheritence, ubiquitous dynamic
binding, cyclical memory graphs, pointer-rich data structures, and
shared-visibility concurrency are all avoided in Rust. The legitimate
motivations for these features are addressed via other means.

Fourth, Rust rejects models of computation that require expensive
runtime mechanisms to support, or appear to be ``hiding'' important
aspects of real computing machinery behind too much abstraction. Of
course this distinction is aesthetic and subjective.  To be specific:
Rust intentionally omits lazy or implicit evaluation, implicit data
parallelism, software transactional memory and tracing garbage
collection. Rust presents a model of computation deemed ``most
obvious'' on Von Neumann machines: linear memory segments with
explicit owners, explicit co-routines and communication primitives,
and strict, sequential execution within primary routines. Parallelism
is supported -- indeed it is ubiquitous in Rust's abstractions -- but
only in explicit terms.


@node    Lexicon
@chapter Lexicon

Rust is defined in terms that may be familiar to readers experienced
with other programming languages. Nevertheless it is important to
clarify the meaning of certain terms which are used in precise, and
occasionally unusual ways within the language definition.

In the following sections, some terms are used but not defined. In
some cases example code is given with portions unexplained. The
purpose of the following sections is to provide suggestive intuitions
about major concepts in Rust. Precise definitions are provided in
later chapters.


@node    Programs and Processes
@section Programs and Processes

Rust borrows operating system terminology in order to differentiate
two important artifacts: @i{programs} and @i{processes}. A program is
the inert, non-executing form of rust code. A process is the
instantiated, ``live'', possibly-executing form of rust code. A
program can be executed, a process @emph{is an executing instance} of
a program; every process has a program that it is currently executing.
We will use these terms precisely and non-interchangeably.

Programs and processes are Rust's fundamental units of encapsulation,
state, behavior and concurrency. A collection of rust code may define
many distinct programs, and each program can be instantiated into many
distinct processes. Processes execute functions, exchange messages
with other processes, and may spawn further sub-processes. Processes
may execute concurrently, or may have their execution interleaved.

There is some similarity between the OOP terms ``class'' and
``object'' and the Rust terms ``program'' and ``process''. In OOP,
classes are instantiated into objects; in Rust, programs are
instantiated into processes. This similarity may help your intuition,
but it is not enough to motivate us to adopt the OOP terminology:
there are sufficient differences between Rust's process model and OOP
that such terminology would cause confusion. Rust does not define
anything called a ``class'' or an ``object''.

When we wish to speak of operating system processes we will use the
term ``operating system processes'' or ``OS processes''; otherwise the
word ``process'' refers to a rust process. Rust processes are
considerably smaller and more lightweight than operating system
processes: a single OS process running Rust code may contain thousands
or millions of Rust processes.

We may sometimes speak of ``a program doing something''. This is a
short-hand way of saying that ``a process that is an instance of the
program would do something''. Programs themselves do not @emph{do}
anything; they are inert values, pieces of text. The difference is
important to maintain in your mind, as Rust defines very different
operations on programs and processes. Programs may be parsed, printed,
copied, transmitted, compiled, typechecked or executed. Processes may
be started, paused, resumed, stopped, or queried for various execution
parameters.

@node    Values and Slots
@section Values and Slots

Rust programs manipulate values. A Rust @i{value} is any information
that can be denoted by a Rust term. Values occupy memory: every value
consumes a certain number of bits. Numbers are values, as are strings,
records, vectors, programs, processes, and many other things
besides.

Some values have slots. A @i{slot} is a named set of bits
@emph{inside} a value that can @emph{refer to} another value, either
directly by containing the referent, or indirectly by storing a memory
address of the referent. Variables within a module or stack frame are
slots, as are the fields within records or the components of vectors.

@node    Types, Forms, Predicates, Constraints and Conditions
@section Types, Forms, Predicates, Constraints and Conditions

Every Rust slot has a type. A @i{type} is a static description of a
subset of all the possible values. A type has two parts: 

@itemize
@item the @i{form} of the type
@item the @i{condition} of the type
@end itemize

The form of a type describes how many bits the type occupies in
memory, and how to interpret those bits. Forms are built from a set of
fundamental ``machine-level'', and can be combined in two ways. First,
code may declare new forms by making ``data'' declarations. These
introduce new forms of record or disjoint union, with specific field
names and a unique constructor name. Second, code may combine existing
types in transparent structural combinations: functions and
vectors. For example, this code:

@example
data employee = rec @{ 
                      string name; 
                      dec salary; 
                    @};

type byte = u8;
type buf = vec[byte];
@end example

introduces 3 new types. The first is a record data type with two named
fields; values of this record type are only form-compatible with slots
declard as type @code{employee}. The second and third present
transparent type abbreviations for unsigned 8-bit values and vectors
thereof; values of the vector type are form-compatible with slots
declared as any other abbreviation for the same type, or indeed merely
declared as the normalized type name @code{vec[u8]}.

The @i{condition} of a type is a set of zero or more constraints. 

A @i{constraint} is a predicate applied to some arguments. Arguments
to a constraint may either be visible slots, or else the implicit
``formal slot'' named @code{*}.

A @i{predicate} is a pure boolean function. We say that a predicate
``holds'' over a value if the predicate returns @code{true} when
applied to the value, otherwise we say that the predicate ``does not
hold'' over the value. We may also generalize this to speak of a
constraint ``holding'' if its predicate holds over the constraint's
arguments, or of a condition ``holding'' when @emph{all} the
constraints in the condition hold.

For example, this code:

@example
pred is_even(int x) @{
  return x % 2 == 0;
@}

pred is_nonzero(int x) @{
  return x != 0;
@}
@end example

defines 2 new predicates: one that tests for even-ness and one that
tests for nonzero-ness. Predicates and types can be bundled together
into a type definition. For example, this code:

@example
type even_nonzero_int = int : is_even(*), is_nonzero(*);
@end example

defines a new name for the type of integers that are even and nonzero.

A slot can refer to a value if and only if the value has the same form
as the slot's type, and the condition in the slot's type holds. For
example, this code:

@example
int foo : is_even(*), is_nonzero(*);
@end example

introduces an integer slot that is constrained to be even and
nonzero. Using our earlier definition, it could be equivalently
written as this code:

@example
even_nonzero_int foo;
@end example

@node    Points, Typestates and Assertions
@section Points, Typestates and Assertions

Rust borrows terminology from the Hermes programming language to
describe a particular static error-checking technique. This technique
is called @i{typestate checking}. To define typestates, we must define
points: a @i{point} exists before or after any statement in a Rust
program. For example, this code:

@example
 s = "hello, world";
 print(s);
@end example

Consists of two statements and three points: 

@itemize
@item the point before the first statement
@item the point between the two statements
@item the point after the second statement
@end itemize

Just as every slot in a Rust program has a dynamic value that conforms
to a static type, every @emph{point} in a Rust program has a dynamic
state that conforms to a static @i{typestate}.  The @i{typestate} of a
point is just a condition -- a set of constraints -- associated with
the point. The typestate of a point is a condition that is statically
guaranteed to hold at that point. The constraints in a typestate can
refer to @emph{any slots} visible at the typestate's point. The static
@i{typestate checking algorithm} ensures that when the program runs,
the dynamic state of the process at a given point @emph{will} conform
to the point's typestate.

Because many predicates are not computable statically -- they depend
on the dynamic state of values -- programmers must occasionally insert
assertions. An @i{assertion} is a statement that calls a predicate
with the built-in operator @code{assert}; this operator prevents
execution from proceeding if the predicate does not hold over the
provided arguments. Failed assertions generate runtime exceptions,
preventing control from proceeding past the assertion. Statically, an
assertion add its constraint into the typestate of the point after the
assertion. For example, this code:

@example
int x;
int y : is_even(*);
x = foo();
y = x;
@end example

consists of two slots -- @code{x} and @code{y} -- and two statements,
thus three points. The first statement calls @code{foo} and assigns
its result to @code{x}. The second statement assigns @code{x} to
@code{y}. This code is @emph{erroneous} according to the typestate
checking algorithm: the point before the second statement does not
contain the @code{is_even(x)} constraint, so the assignment would
violate the condition of @code{y}.

The code can be corrected using an assertion. This corrected code:

@example
int x;
int y : is_even(*);
x = foo();
assert is_even(x);
y = x;
@end example

Consists of three statements and four points. At the first two points,
the typestate does not contain the @code{is_even(x)} constraint. At
the third point -- the point @emph{after} the assertion -- the
typestate @emph{does} contain the @code{is_even(x)} constraint. So the
third statement is now legal: if the third statement ever executes, it
will assign a value @emph{statically} known to satisfy the condition
of @code{y}.

It is crucial to understand that the typestate of the third point is a
@emph{static} fact about @emph{static} entities -- slots, points and
predicates -- even though the runtime behavior will vary depending on
the runtime value of @code{x}. If the predicate fails at runtime,
control will not proceed past the @code{assert} statement, and the
assignment will never be made.

To reiterate: the typestate checking algorithm is not responsible for
statically evaluating constraints. It simply calculates the
constraints that are @emph{known to hold} at each point -- if control
ever reaches the point -- and reports on mismatches between the
constraints known to hold at a point and the constraints
@emph{required} by statements.

Typestates encode requirements for complicated dynamic assertions in
the language's static checking system. This makes it easier to rule
out erroneous inputs to functions and programs that you write:
function parameters and return values are slots just like variables,
and can be annotated with conditions. In this respect typestates are
similar to a form of ``design by contract'', except that the typestate
checking algorithm examines the static control-flow graph and
minimizes the number of times an expensive assertion must be
(re-)checked.


@node    Artifacts
@chapter Artifacts

@page
@node    Structural artifacts
@section Structural artifacts

A collection of Rust source code can be thought of @emph{structurally}
as a set of artifacts that logically @i{contain} one another. There
are four kinds of artifacts in this view: @i{crates}, @i{modules},
@i{slots} and @i{values}.

@subsection Crate

A @dfn{crate} is a unit of configuration, linkage and distribution
for Rust code. Crates logically contain modules. Crates have
``unfriendly'' names -- names that look like ugly and meaningless
numbers -- but these names are ``universally unique''.

The source form of a crate is a @dfn{crate file}, which is a
text file ending in @code{.rc}. The compiled form of a crate is a
binary dynamic-link library, such as an ELF or PE library (ending in
@code{.so} or @code{.dll} respectively).

Crate files contain a description of a tree of modules, and
instructions about how to compile the crate. The Rust compiler
operates on crate files. Crate files may reference other
crates, in order to import qualified module names from them, but
the reference graph of crate files is a DAG.

@subsection Modules

A @dfn{module} is a unit of @emph{name organization} within a
crate. The tree of modules in a crate corresponds 1:1 with a tree of
directories and files in a filesystem. Thus there are two kinds of
modules: @dfn{directory modules} and @dfn{source modules}. A directory
module contains sub-modules. A source module contains values.

Source modules, also called @dfn{source files}, are files ending
in @code{.rs}. These files contain code that defines slots.

Modules are arranged in a human-friendly namespace within a crate.
It is the responsibility of a team of programmers working on a
crate to ensure that their module names to not collide, inside the
crate. Module names can be reused in different crates,
however; the names in one crate are unrelated to the names in
another crate.

Modules contain slots, and some of those slots point to values. There
are many types of value; the complete list is provided in the next
section. For now it is sufficient to note that most Rust code is
concerned with manipulating values. Much more than the portion of Rust
code that relates to modules and crates.

@subsection Slots

Finally, within modules there are @i{slots}. A @dfn{slot} is a named
memory location that can refer to a value. Some values will contain
more slots, that in turn may refer to more values. Each source module
defines a set of slots that are the ``top level'' slots of the
module. Further slots exist in many contexts:

@itemize
@item Variables within functions, ports and predicates.
@item Fields within records, alternatives and programs.
@item Components of vectors.
@end itemize


@page
@node    Values
@section Values

Rust defines a wide variety of types and type constructors.

@menu
* Primitive types::           Machine-level values.
* Dynamic types::             Latently-typed values.
* Arithmetic types::          High-precision numbers.
* Textual types::             Strings and characters.
* Records::                   Fixed products of heterogeneous types.
* Vectors::                   Dynamic products of homogeneous types.
* Alternatives::              Sums of heterogeneous types.
* Functions::                 Subroutines and scoped coroutines.
* Predicates::                Pure functions involved in typestates.
* Programs::                  General coroutines.
* Processes::                 Instances of programs.
* Ports::                     Inter-process message inputs.
* Channels::                  Weak capabilities to send messages to ports.
* Types::                     Values representing types.
* Quotations::                Values representing source code.
@end menu

@node       Primitive values
@subsection Primitive values

@node       Dynamic values
@subsection Dynamic values

@node       Arithmetic values
@subsection Arithmetic values

The types of arithmetic value are:

@itemize
@item @code{nat}, the type of arbitrary-precision naturals.
@item @code{int}, the type of arbitrary-precision integers.
@item @code{rat}, the type of arbitrary-precision rationals.
@end itemize

All these types are represented internally as alternatives; on N-bit
systems, typically, N-1-bit integral values of any of these types are
stored as single machine words.

@node       Textual values
@subsection Textual values

The types of textual value are:

@itemize
@item @code{char}, the type of unicode codepoints, as @code{u32} values.
@item @code{str}, the type of unicode strings, equal to @code{vec[char]}.
@item @code{strenc.utf8}, a @code{vec[u8] : strenc.is_utf8(*)}, the type of unicode strings encoded into UTF-8.
@item @code{strenc.*}, various other character encodings.
@end itemize

It should be emphasized that the primary string type should not be
blindly memory-copied into an external buffer, as it will produce a
sequence of numbers in the host byte order, and not necessarily equal
to a particular UTF-8 or UCS-4 encoding. When externalizing a string,
care should be taken to select an appropriate encoding from the
standard @code{enc.*} module.

@node       Records
@subsection Records

The @code{rec} type introduces new record types that have named fields,
similar to the @code{struct} types of C.

Anonymous record literals and record types are denoted with the
keyword @code{rec}. The fields of a record are defined, as a sequence
of slot declarations within braces, similar to the slot declarations
in a stack frame.

Record fields can carry ``inline'' conditions, similar to slots in a
stack frame. Complete record types can also carry conditions relating
to the record as a whole, or to some combination of its fields.

@node       Vectors
@subsection Vectors

Vectors are variable size, homogeneous, 1-dimensional containers. 

Vectors are parametric types, denoted with the keyword
@code{vec}. Anonymous vector literals and vector types containing type
@code{T} are denoted as @code{vec[T]}.

A vector has two associated sizes: one representing the vector's
allocated size, and one representing a bound on the initialized range
of the vector. Within the initialized-range bound, all elements carry
the @code{init} predicate. 

Vectors dynamically resize using doubling and halving operations that
amortize byte-copying costs to a constant factor per element.

Because the @code{init} predicate is managed homogeneously over the
initialized range of the vector, not per-element, vectors cannot have
individual elements deinitialized. Instead, the following operations
are defined:

@itemize
@item Elements can be swapped inside the vector.
@item An element of the appropriate type can be appended to the vector.
@item A vector of the same element type can be appended to the vector.
@item The vector can be truncated to any size smaller than its current size.
@item An element of the vector can be swapped with an external, initialized value.
@end itemize

Vector types can have an associated condition that applies to every
element in the vector, or to the vector as a whole.

@node       Alternatives
@subsection Alternatives

Alternatives are structures that contain, at any given point, exactly
one of an explicitly enumerated set of possible values.  They are
similar to the disjoint sum types of ML, and can be seen as a ``safe''
version of @code{union} types in C.

Alternatives are denoted with the @code{alt} keyword. The possible
values of the alternative are called @i{cases}, and the cases are
denoted with unique identifiers, that act as labels.

The space consumed by an N-alternative has two components:

@itemize
@item The space for the cases, which is the maximum space required 
for any of the cases. This space is used regardless of case.
@item The space for the discriminant field, which is @code{ceil(log_2(N))}
bits.
@end itemize

If the space consumed by an alternative can fit inside a single word,
Rust is obliged to store it this way. In particular, on a machine that
effectively ``does not use'' K low bits of its pointers (due to
alignment restrictions), those K low bits can be used to encode a
@code{2^K}-case alternative. Every implementation of Rust must perform
this optimization.

@node       Functions and Channels
@subsection Functions and Channels

Functions and channels model control transfer abstractions. Functions
model synchronous subroutines as well as 4 limited, stack-scoped forms
of synchronous coroutine. Channels are effectively weak pointers to
synchronously-invoked functions that may execute in different
processes.

Function and channel calls provide arguments, as well as either one or
two points in their caller's frame to return and/or yield to. A call
@i{returns} a value if it moves a value into the caller-allocated
return slot, deallocates its frame and signals caller control to jump
to the return point. A call @i{yields} a value if it moves a value
into the caller-allocated yield slot, moves a ``resume point'' and a
``terminate point'' into the caller-allocated resume/terminate slots,
signals caller control to jump to the yield point, and @emph{does not}
deallocate the callee frame. If a call yields, the caller may
@i{resume} the call and permit it to return of its own accord, or may
@i{terminate} the call, causing the execution of callee's epilogue and
deallocating its frame. Every call eventually executes its epilogue,
either caused by a return, an exception, or caller termination. 

The callee of a channel call is a port, and ports may asynchronously
and independently be terminated on the callee side at any point during
the call, since they are controlled by an owning process of their
own. The callee of a function call is a function body, which trades
control back and forth with its caller synchronously. In both channel
and function calls, caller control suspends when callee control is
active. 

The arguments to a function or channel implicitly occupy an ``argument
record'', though it is a special record declared and managed
automatically by the language. In the case of a function, the argument
record may be coincident in memory with the slots of the
callee. Arguments flow through the argument record transparently, most
of the time. The only time it is relevant to know about is when
aplying an unknown function or channel type to an unknown
argument-record type. In that case, the argument-record type
associated with the function must be compatible with the function it
is being combined with. For a function type @var{T}, the argument
record type is a nested type called @code{T.args}.

An un-annotated parameter implies that the associated argument is
copied into the argument record during a call, then copied into the
caller's frame.  A parameter slot of type @code{T} can be annotated in
three additional ways:

@itemize
@item @code{T-}, which means ``move in''
@item @code{T+}, which means ``move out''
@item @code{T=}, which means ``move in and out''
@end itemize

A ``move in'' parameter is moved from the caller frame into the
argument record and then into the callee frame: the caller's slot loses
its @code{init} predicate at the point of the call, and the callee
gains it. The mnemonic is that @code{T-} parameters ``consume'' values
of type @code{T} from their caller.

A ``move out'' parameter is moved from the callee frame into the
argument record and then back to the caller frame when the call
returns. The callee slot loses the @code{init} predicate at the return
point, and the caller slot gains it.  The mnemonic is that @code{T+}
parameters ``produce'' values of type @code{T} for their caller.

A ``move in and out'' slot does both of the above.

Yields do not move values into ``move out'' or ``move in and out''
parameter slots; only returns.

Un-annotated yield and return slots use copy semantics. They can be
annotated with the @code{+} suffix to imply ``move out'' semantics. 

Parameter types, return types and yield types can all be annotated as
exterior using the @code{^} prefix, just like all slot
declarations. Parameter types and yield types can also be annotated as
aliases using the @code{@@} prefix. See @ref{Slot modes}.

Functions are required to support proper tail-calls.

Functions may be pure. A pure function performs no communication
tasks: it does not send on any channel, nor does it spawn or otherwise
interact with a process type. See @ref{Purity}.

In addition to the basic call/return protocol for functions, which is
declared with the @code{func} keyword, 4 types of scoped coroutine are
supported, that may yield before they return:

@itemize
@item @code{func!} denotes a function that yields exactly once.
@item @code{func?} denotes a function that yields 0 or 1 times.
@item @code{func*} denotes a function that yields 0 or more times.
@item @code{func+} denotes a function that yields 1 or more times.
@end itemize

These protocols are also supported by channels and ports, with the
channel keywords @code{chan!}, @code{chan?}, @code{chan*} and
@code{chan+} and the port keywords @code{port!}, @code{port?},
@code{port*} and @code{port+}.

Scoped coroutines are also required to support proper
tail-@emph{yields}. A tail-yield occurs when a primary coroutine
invokes a sub-coroutine with a construct that yields every value
yielded by the sub-coroutine. Then the primary coroutine passes its
caller's yield address to the sub-coroutine, for direct yielding
between the sub-coroutine and caller. When such a tail-yield happens
in tail-call position (the last statement of a coroutine before a
return), the coroutine is requried to replace its stack frame with the
frame of the sub-coroutine, as with a return-based tail call.

The 4 types of coroutine combine with 4 specific caller-side control
structures (@code{for!}, @code{for?}, @code{for*} and @code{@for+}) to
support 4 important calling patterns. Each is useful, and interacts in
a precise manner with the typestate checking algorithm. One way to
picture the differences is to picture the control-flow graph in the
caller: when binding a yielded value inside a temporary control block,
the caller's control graph has either none, one, or both of a ``bypass
edge'' (if no yield occurs) and a ``back edge'' (if more than one
yield occurs). Combining these possibilities produces 4 possible
scenarios: neither (@code{func!}), bypass-no-back (@code{func?}),
back-no-bypass (@code{func+}) and both (@code{func*}).

A function declaration also defines an associated @i{call record} that
represents the parameter-passing requirements of the function in a way
that is accessible to introspection or polymorphic invocation. This
record contains an @i{arguments record}, and either a @i{return value
slot} or @i{yield value slot}. Given a call record, there are 5
polymorphic @i{apply} operators that will invoke a function of
compatible type. Invocation involves forming a callee frame full of
slots for each value in the call record's argument record, copying or
moving values into those slots, then running the callee. Yields and
returns from the function are tail-yielded or tail-returned back to
the caller of the apply operator. This permits writing polymorphic
call-proxying code while keeping the standard case efficient.


@node       Predicates
@subsection Predicates

Predicates are boolean pure functions that connect runtime values to
the typestate system. The typestate system statically assigns a
condition to each point in a program, and checks that conditions
required by statements are met at every point. A condition is a set of
constraints. A constraint is a predicate applied to slots. Thus,
introducing a new predicate enlarges the set of possible constraints
and conditions. See @ref{Typestates}.

Predicates are declared with @code{pred}, and have names and
signatures similar to functions. The body of a predicate is
syntactically a pure boolean function. The signature of a predicate
cannot include the keyword @code{pure} or the @code{bool} return type;
these are implied and non-optional.

Conditions can be asserted with the keyword @code{assert}. The
postcondition of a statement @code{assert p(q,r), x(y,z)} is the union
of the precondition with the condition @code{p(q,r), x(y,z)}.

@node       Programs
@subsection Programs

@node       Processes
@subsection Processes

@node       Ports
@subsection Ports

@node       Channels
@subsection Channels

@node       Types
@subsection Types

@node       Quotations
@subsection Quotations


@page
@node    Type system
@section Type system


@node       Value and slot types
@subsection Value and slot types

Every value has a unique form.

Every slot has a unique type.

If a slot @var{S} references a value @var{V}, type of @var{S} has a
form that is identical to the form of @var{V}, and the type of @var{S}
has a condition that holds when @var{V} is substituted for the formal
slot @code{*} in the condition. Of course @var{S} may be further
constrained by other constraints at its point of declaration, but
those constraints @emph{add} to the condition in the type of
@var{S}. They do not replace it.


@node       Limitation
@subsection Limitation

Some types are @i{limited}. A type @var{T} is @dfn{limited} iff any of
these constraints hold:

@itemize
@item The type @var{T} contains a limited slot.
@item The type @var{T} is @code{proc}.
@item The type @var{T} is @code{addr}.
@end itemize

Limited values cannot be copied or transmitted, only moved. See
@ref{Memory model} for the definitions of copying and transmission.

Limitation ``infects'' the structure that contains it; any type that
is indirectly limited must be declared as such with the keyword
@code{lim}.

@node       Addresses and memory safety
@subsection Addresses and memory safety

Values of the @code{addr} type are memory addresses of blocks of
memory acquired from the operating system or libraries written in
other languages. To differentiate types of address, use the @code{new}
type operator in an @code{addr} type expression. Address types also
carry a finalizer that cleans up after them. Use of an address type
marks a program as ``memory unsafe'', which makes any process that
runs the program ``memory unsafe''. To regain memory safety, a process
must be run inside a separate operating system process with hardware
memory protection. Dividing your programs up into independend
operating system processes to localize memory unsafety is part of
normal Rust program design.

@node       Purity
@subsection Purity

Functions may be @i{pure} or @i{impure}. A
function @var{S} is @dfn{impure} iff any of these constraints hold:

@itemize
@item The function @var{S} is @emph{not} declared as @code{pure}
@item The function @var{S} calls any impure functions.
@item The function @var{S} calls any channels.
@end itemize

Purity exists as a concept in Rust for two reasons:

@itemize
@item As a basic aid to code comprehension. Pure functions are easier
to reason about, so programmers may wish to ensure that portions of
their work are pure.
@item Predicates are effectively pure boolean functions. Predicates
are @emph{required} to be pure for the typestate system to function
correctly. Since purity is required for predicates, extending the
concept of purity to functions and iterators permits predicates to
call them safely. Otherwise predicates would have to be
self-contained.
@end itemize
    

@page
@node    Typestates
@section Typestates

Every block of statements containing expressions decomposes to a block
of primitive statements in a normal form. In this form, every
statement is logically one of:

@itemize 
@item A statement declaring a slot.
@item A conditional or unconditional jump to another statement.
@item A load statement on one slot.
@item A copy or move statement on two slots.
@item An ALU statement on three slots.
@item A heap allocation or deallocation statement.
@item Invocation of a function or channel.
@item A return or yield.
@end itemize

Every normalized statement has two associated @dfn{points}: one before
the statement and one after the statement. Each point has an associated
@emph{condition}:

@itemize
@item The @dfn{precondition} of a statement is the condition the statement requires in the point before the condition.
@item The @dfn{postcondition} of a statement is the condition the statement enforces in the point after the statement.
@end itemize

Any constraint present in the precondition and @emph{absent} in the
postcondition is considered to be @emph{dropped} by the statement.

The typestate checking system analyzes the preconditions and
postconditions of each statement, and calculates a condition for each
point called a typestate. For a given statement, we call these
typestates the prestate and a poststate.

@itemize
@item The @dfn{prestate} of a statement is the typestate of the point before the statement.
@item The @dfn{poststate} of a statement is the typestate of the point after the statement.
@end itemize

A @dfn{typestate} is a condition that has @emph{been determined by the
typestate algorithm} to hold at a point. This is a subtle but important point to 
understand: preconditions and postconditions are @emph{inputs} to the typestate
algorithm; prestates and poststates are @emph{outputs} from the typestate algorithm.

The typestate algorithm analyzes the preconditions and postconditions
of every statement in a block, and attempts to compute a condition for
each typestate. Specifically:

@itemize
@item Initially, every typestate is empty.
@item Each statement's poststate is given the union of the statement's prestate, precondition, and postcondition.
@item Each statement's poststate has the difference between the statement's precondition and postcondition removed.
@item Each statement's prestate is given the intersection of the poststates of every statement that jumps to it.
@item The previous three steps are repeated until no typestates change.
@end itemize

After the typestates of a block are computed, the typestate algorithm
checks that every constraint in the precondition of a statement is
satisfied by its prestate. If any preconditions are not satisfied and
no automatic assertions exist, the mismatch is considered an error.

@node       Asserting conditions
@subsection Asserting conditions

The @code{assert} statement adds the constraints in the asserted
condition to its postcondition. At runtime, if the assertion succeeds
it has no effect, and if it fails it raises an exception. If a
predicate is declared as @code{auto}, assertions are inserted
automatically some contexts.

Specifically: When checking whether a statement's precondition is
satisfied by its prestate, if the precondition names a predicate that
is not present in the prestate, one of two cases occurs:

@itemize
@item If the missing predicates are all @code{auto} and all the 
preconditions of the missing @code{auto}-predicates are met, the
compiler may insert assertions for each missing predicate (and restart
the typestate algorithm).
@item Otherwise the condition is a compile-time error.
@end itemize

@node       Dropping constraints
@subsection Dropping constraints

All constraints in a typestate can be @i{dropped}. To @dfn{drop} a
constraint is to remove it from the typestate at the associated
point. For a slot @var{S}, dropping the @code{init(S)} constraint may
cause memory to be released or finalizer to be run. See @ref{Memory
model} for discussion. All other constraints can be dropped without
side-effect.


@node       Constraints on moved values
@subsection Constraints on moved values

When a statement moves a value from a slot @var{A} to a slot @var{B}: 

@itemize
@item Every constraint involving @var{B} is dropped.
@item Every remaining constraint involving @var{A} has @var{B} 
substituted for @var{A}.
@end itemize


@node       Constraints on copied values
@subsection Constraints on copied values

When a statement copies a value from a slot @var{A} to a slot @var{B}: 

@itemize
@item Every constraint involving @var{B} is dropped.
@item For every remaining constraint @var{P} involving @var{A}, 
a copy of @var{P} is added to the typestate with @var{B} substituted
for @var{A}.
@end itemize


@node          Slot conditions
@subsubsection Slot conditions

When a slot @var{S} has a type @var{T} with condition @var{C}, it
means that all the constraints in @var{C} will be present, with
@var{S} substituted for the formal slot @code{*}, in the typestate of
every point to which @var{S} is @i{visible}.

A slot becomes @dfn{visible} at the point immediately following the
statement containing its declaration, and remains visible through to
the point after the last statement in the block containing the slot's
declaration.


@node       Reflection
@subsection Reflection

Types and constraints are reflected into runtime values. Runtime values
can always be converted to type @code{dyn} or @code{lim dyn}, which
carries the type of its value and type (both form and state) along
with it.

The runtime representation of a type can be compared to the runtime
representation of another type.

To connect runtime and compile-time values, a type-switch statement
exists over @code{dyn} values; each arm of the type-switch
temporarily moves the @code{dyn}'s value into a typed slot.


@node       Type system comparison with other languages
@subsection Type system comparison with other languages

We borrow structure (but not terminology) from Ada and Hermes when
organizing the type system. In particular:

@itemize
@item All rust types carry conditions, similar to an Ada "subtype". Conditions are formulated using Hermes-style 
predicates rather than Ada's fixed set of constraints.
@item There is no general subtype lattice (as in OO languages). There is only
one type for each value. This is common between Rust and Hermes.
@end itemize


@node       Pragmatic notes
@subsection Pragmatic notes

Type conditions do not participate in function overload resolution,
because predicates can always be dropped. Only type forms are
considered in when resolving overloaded function names.

If you wish to produce a new type that wraps an old type and
@emph{does} participate in overload resolution (and is
assignment-incompatible with the old type), you can use the @code{new}
type operator. This operator produces a disjoint form that shares the
same structure as its operand, but compares unequal for purposes of
assignment compatibility. Disjoint forms with the same bitwise
structure can be coerced to one another, but only explicitly, and only
when the definitions of both types are visible (i.e. when neither is
an opaque export from another module).

It would be pointless to prohibit such coercion on the grounds of
safety, since programmers can always write their own coercion
functions by analyzing one form bit-by-bit and building the other
bit-by-bit. Use coercion lightly and tastefully.

@page
@node    Memory model
@section Memory model


@node       Semantic model
@subsection Semantic model

Rust's memory model logically consists of a set of values, arranged in
a logical tree, and physical DAG. Values have 1:1 type relationship so
values may be said to be limited or not, just like types. See
@ref{Limited types} for details.

The relationships between slots and values are the edges in the memory
DAG.


@node       Initialization 
@subsection Initialization 

Every slot is either @i{initialized} or @i{empty}.

A slot @var{S} is @dfn{initialized} iff it refers to a value in the
memory DAG, otherwise @var{S} is @dfn{empty}. When the slot
@var{S} is initialized, the predicate @code{init(S)} is added to the
typestate. If the predicate @code{init(S)} is dropped, the slot
@var{S} becomes empty.


@node       Sharing
@subsection Sharing

Semantically, every slot holds a unique subtree that is not
shared. This is why we say that memory is arranged into a logical
tree.

In physical memory, some number of memory subtrees may be shared
copy-on-write (CoW). This is why we say that memory is a DAG. The
amount of sharing is specified and obligatory: exterior allocations
have reference counts stored at the beginning of their allocation, and
are reclaimed when the reference count drops to zero. Interior
allocations are reclaimed when the slot containing the allocation
becomes empty (loses the @code{init} predicate). See @ref{Allocation
modes}.


@node       Assignment
@subsection Assignment

Rust has two built-in notions of assignment. 

First, one can @dfn{move} a value between slots. Movement is
written with the operator @code{<-}; an example is @code{B <- A;}
which means "move A to B". All values can be moved. 

Second, one can @dfn{copy} a value between slots. Copying is
written with the operator @code{=}; an example is @code{B = A;}
which means "copy A to B". Limited values cannot be copied.

In both move and copy assignments, the left slot is called the
@dfn{destination} and the right slot is called the @dfn{source}.

The affect of copying and movement on typestates is described in
@ref{Predicates and assignment}. In short, predicates associated with
the destination slot are dropped, and predicates associated with the
source slot are either replaced or duplicated to refer to the
destination slot.

The @code{init} predicate models the initialization state of a slot,
and thus the presence or absence of a slot's reference to a
value. When an @code{init} predicate is dropped during an assignment,
it may thereby drop a reference to a value. This in turn may cause
either finalization -- if the value is limited and contains processes
with finalizers -- and/or storage reclamation, if the unreferenced
value was exterior-allocated (see @ref{Allocation modes}).

The behavior of a move or copy is completely defined by the typestate
transition rules in @ref{Predicates and assignment}, as well as one
additional rule: that in either @code{B = A;} or @code{B <- A}, if the
prestate has @code{init(A)} and slot @var{A} refers to value @var{V}
before the assignment, then slot @var{B} refers to value @var{V} after
the assignment.


@node       Allocation modes
@subsection Allocation modes

Values can be allocated in either an @i{exterior} or @i{interior}
mode. @dfn{Exterior allocation} typically means ``allocated on the
heap''. @dfn{Interior allocation} means that the value is allocated
within a contiguous block of memory owned by some other
value. Interior allocations are commonly made for slots in @code{rec}
and @code{vec} values, as well as slots in function and port frames.

Slots also have modes, each of which may imply that the slot's
referent has a particular allocation mode. See @ref{Slot modes}.


@node       Value transplanting
@subsection Value transplanting

When a value is moved or copied into a slot that requires an
allocation mode different from the allocation mode of the value, the
value may be @i{transplanted} during the move or
copy. @dfn{Transplanting} a value means moving or copying the value by
byte-copying it into a new location in memory. Transplanting may also
involve allocating fresh memory from the heap, if the transplant
destination is exterior.

Rust's memory model strives to minimize four things simultaneously: 

@itemize
@item Ambiguity of notation.
@item The amount of value transplanting.
@item The amount of exterior allocation.
@item Cognitive load for programmers.
@end itemize


@node       Type size
@subsection Type size

Any visible slot consumes a fixed amount of memory: either to store a
value directly or to store the address of a value elsewhere in
memory. The amount of memory required for a slot may only become known
at runtime, and the value the slot refers to may change the amount of
memory it consumes, but once elaborated the slot itself does not
change size during its life.

Some slots refer to values -- vectors and processes -- that may
themselves consume dynamic amounts of memory, but the slots referring
to those vectors and processes are fixed-size descriptors synthesized
by the compiler. A programmer may not independently refer to the
dynamic portion of a vector or process.

Slots may have their size determined at compile time. Such slots are
said to have @dfn{static size}, and are subject to precomputing and
inlining of various allocation, copy and move operations.

Other slots -- those referring to parametric types -- may only have
their size determined at elaboration time. Such slots are said to have
@dfn{deferred size}, and must calculate sizes for most memory
operations dynamically, using type descriptors present at elaboration
time.

Types that fit inside a single machine word are called
@dfn{subword}. Types that do not fit inside a single machine word are
called @dfn{superword}.

@node       Slot modes
@subsection Slot modes

Slots have modes. A slot's mode determines how the slot relates to its
referent. There are three slot modes:

@itemize
@item Exterior
@item Alias
@item Interior
@end itemize

A slot is exterior iff it is @emph{marked} with the ``exterior'' slot
prefix @code{^}. By writing @code{^T} for a slot with type @code{T},
the programmer states that the slot will always refer to an exterior
allocation. Exterior slots are always exactly 1 word in size, so by
marking parts of a data structure as exterior, they permit programmers
to control the ``shape'' of the data structure in memory, and trade 
speed of copying for speed of access. 

Exterior slots also permit defining recursive types: it is a static
(compile-time) error to denote a type that contains instances of
itself transitively, without passing through an exterior slot, simply
because such types would have infinite elaboration-time size. All such
cases can be detected statically: types cannot be @emph{created} after
compile time, even if some size calculations are deferred until
elaboration time. The point of deferred sizes is merely to avoid
having to duplicate code that only differs in slot-size calculations.

If an exterior slot has deferred size, it may happen that the
elaboration-time size of the slot is subword. If so, no @emph{actual}
exterior allocation will occur: it is just as efficient to pass an
immediate value around in place of an exterior address, and
semantically indistinguishable. Rust implementations are required to
perform this elaboration-time optimization.

It should be emphasized that the @code{^} qualifier does @emph{not}
produce an separately denotable concept of ``address'': there is no
mechanism for denoting or manipulating the address stored in an
exterior slot, and all the type-state rules are identical for all slot
modes.

Exterior slots manipulate reference counts of exterior allocations, in
order to enforce copy-on-write sharing of the exterior memory graph.
The performance penalty of exterior allocation and reference counting
may be eliminated in some cases by using alias slots.

A slot is an alias iff it is @emph{marked} with the ``alias'' type
prefix @code{@@}. By writing @code{@@T} for a slot with type @code{T},
the programmer states that the slot has the following properties:

@itemize 
@item The slot has the @code{init} predicate everywhere it is visible
@item The slot is not written to anywhere it is visible
@end itemize

The only cases where aliases are legal are function and port parameter
slots, yield slots, and the arms of @code{alt} statements. Read
operations such as copying from an alias, or performing ALU operations
that read from an alias, are permitted. This extends to any names
formed "through" a alias. So long as the alias remains visible and is
not written to. It is a static error to write to (or through) an
alias. Reading through an alias into any other type of slot produces a
copy. These restrictions are required to prevent aliases from being
used to defeat the DAG nature of the memory graph: if you could write
through an alias, you could construct a node and pass ownership of the
node to itself through an alias, creating an ownership cycle.

Aliases may hold addresses of either interior or exterior values, but
do @emph{not} manipulate exterior reference counts, deinitialize or
deallocate values. It is a static error to mark a slot as an alias if
the alias-ness properties cannot be statically proven, so only
specific syntactic contexts permit alias slot declarations.

Like exterior slots, alias slots are always 1 word in size. Also
like exterior slots, alias slots with deferred size are required
to optimize away any address indirection that might result from
elaboration on a subword-size type, and copy the referent
itself. Essentially both exterior slots and aliases will behave as
interior slots if their referent type fits in a word.

A slot is interior if it is neither exterior nor an alias. Every
copy or move is a transplant, every value allocation is inline with
the slot container.

Implementations may issue warnings about exterior or alias slots
with static subword size: such declarations are meaningless -- the
slot will always behave as interior -- and thus detract from program
comprehension.


@node Index

@printindex cp

@bye
