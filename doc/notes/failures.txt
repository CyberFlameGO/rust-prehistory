
- budget exceeded
  - time
  - space
  - other (dyn)
- resource too busy
  - entry queue depth exceeded
- program logic error
- input error
- hardware error


transient / permanent
local / propagated


signalling:

  - sync local sw signals: logic error, overflow, etc.
  - async local sw signals: alarms, "please kill this lwp"
  - async sw env signals a la unix (timer, sigchild, sighup, etc.)
  - async hw env signals: fpu, ipi, io interrupt

mesa suggests we can restart with a value if signals have restart types.

in rust process model, unwinding affects dynamic call chain, might
leave callee process intact (in accept loop) while unwinding caller. 

should signal handler be able to change status of callee (eg. to
"broken, please reset me")? or propagate signal to callee's owner?

crucial points: 

  - well-defined signal prioritization, masking, saturation, dropping.
    no implementation-defined races. text must do what it says, even
    if the most precise form is a bit verbose.

  - implementability: what are the atomic hw ops we have these days?
  - comprehensiveness: what are the hw/sw env requirements?
  - usability: can users get it right most of the time?


what can we borrow from the existing lexicon?

  - exceptions that unwind the dynamic stack
  - signals that result in "spontaneous calls"
  - erlang: exception that hits a process' mainloop kills process,
    signals owner/group.

possible picture (from hermes?):

  - calls have declared exns, plus "failed(dyn)" exn
  - in rendezvous, callee may return callmsg in exn state yet resume
    mainloop w/o exn
  - if exn propagates to the point of discarding callmsg w/o concrete
    return, return is in "failed" exn state.
  - if exn hits process mainloop, process is terminated, async signal
    is optionally sent to owner/group.
  - signals == message delivery
    - interface involves binding (proc,signal)->port
    - if no handler bound, throws "failed(signal)"
    - if port overflows, is disconnected or times out, throws "failed(signal-delivery)"
    - if unwinding exceeds budget, stops pc and signals owner/group
    - open question: what if env races with our delivery? can it be made to not do so?

simpler picture:

  - crate has dynamic-scoped handler list called an "fault", per proc-in-that-crate (null initially):

     fault foo(IN) -> OUT;

  - push a handler on this list, dynamically scoped, via "trap":
    (this can be a "virtual" list provided by DWARF CFI, or via a real list, doesn't matter)

      trap (foo = (handler, thingy)) { ... }

  - when you hit an exceptional circumstance, you raise it:

      if (... ) {
        x = foo();
      } else {
        // "uh oh, call a handler"
        x = raise foo(gurgle);
      }

   what happens?

   - If handler list is empty, fail
   - Else call head of handler list and return result
   - Handler may return something
   - Handler may fail, unwinding
   - Once you're failing, proc can't stop; no "catch"
   - Termination model of processes, plus linkage
   - If you *really* want to catch "everything", put it in a
     separate process and wait on its termination

simpler still:

   - declare fault types as above:

     fault foo(int x) -> int;

   - static fault-trapping blocks, like catch blocks:

     try {
       ...
     } trap foo(x) {
       fix x + 10;
     } trap bar(y) {
       log "got a bar";
       fail;
     }

  - when you hit an exceptional circumstance, you raise it:

      if (... ) {
        x = foo();
      } else {
        // "uh oh, call innermost foo trap for help"
        x = raise foo(gurgle);
      }

   - fault-trapping block is invoked *like a fn*,
     located dynamically using a CFI/.eh_frame-like thing.
     zero cost in the not-taken case.

   - trapping block has outer slots in scope, can fix or fail,
     no closure weirdness required, no exceptions-as-values
     nonsense, no lazy stacktrace complexity.

   - "fix" passes a value back down to the fault and continues

   - if fault-trapping block "fail"s, termination model starts

   - this is similar to a subset of the mesa signal system or
     the CL / dylan condition system
