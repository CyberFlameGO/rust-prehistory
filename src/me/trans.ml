(* Translation *)

open Semant;;
open Common;;

type ctxt = 
    {
      mutable ctxt_emit: Il.emitter;
      ctxt_sess: Session.sess;
      ctxt_abi: Abi.abi;
      mutable ctxt_path: string list;
      mutable ctxt_data_items: Asm.item list;
      ctxt_text_items: (string, (Il.quads * int)) Hashtbl.t;
    }


let new_ctxt (sess:Session.sess) (abi:Abi.abi) : ctxt = 
  { 
    ctxt_emit = Il.new_emitter abi.Abi.abi_prealloc_quad abi.Abi.abi_is_2addr_machine;
    ctxt_sess = sess;
    ctxt_abi = abi;
    ctxt_path = [];
    ctxt_data_items = [];
    ctxt_text_items = Hashtbl.create 0
  }

let marker = Il.Imm (Asm.IMM 0xdeadbeefL);;
let imm_true = Il.Imm (Asm.IMM 1L);;
let imm_false = Il.Imm (Asm.IMM 0L);;
let badlab = Il.Label (-1);;


let mark (cx:ctxt) : int = 
  cx.ctxt_emit.Il.emit_pc
;;


let patch (cx:ctxt) (i:int) : unit = 
  cx.ctxt_emit.Il.emit_quads.(i) 
  <- { cx.ctxt_emit.Il.emit_quads.(i)
       with Il.quad_dst = Il.Label (mark cx) }
;;  


let log cx = Session.log "trans" 
  cx.ctxt_sess.Session.sess_log_trans
  cx.ctxt_sess.Session.sess_log_out
;;


let reset_emitter (cx:ctxt) : unit = 
  cx.ctxt_emit <- 
    (Il.new_emitter 
       cx.ctxt_abi.Abi.abi_prealloc_quad 
       cx.ctxt_abi.Abi.abi_is_2addr_machine)
;;


let capture_emitted_quads (cx:ctxt) : unit = 
  let n_vregs = cx.ctxt_emit.Il.emit_next_vreg in 
  let quads = cx.ctxt_emit.Il.emit_quads in 
  let name = String.concat "." (List.rev cx.ctxt_path) in
    begin
      log cx "emitted quads for %s:" name;
      for i = 0 to (Array.length quads) - 1
      do 
        log cx "[%6d]\t%s" i (Il.string_of_quad cx.ctxt_abi.Abi.abi_str_of_hardreg quads.(i));
      done;
      Hashtbl.add cx.ctxt_text_items name (quads, n_vregs);
      reset_emitter cx
    end
;;


let rec trans_resolved_path 
    (cx:ctxt) 
    (resp:Ast.resolved_path) = 
  let emit = Il.emit cx.ctxt_emit in  
    match resp with 
        Ast.RES_pr FP -> cx.ctxt_abi.Abi.abi_fp_operand
      | Ast.RES_pr PP -> cx.ctxt_abi.Abi.abi_pp_operand
      | Ast.RES_pr CP -> cx.ctxt_abi.Abi.abi_cp_operand
      | Ast.RES_pr RP -> cx.ctxt_abi.Abi.abi_rp_operand
      | Ast.RES_idx (a, b) -> 
          let av = trans_resolved_path cx a in
          let bv = trans_resolved_path cx b in          
		  let tmp = Il.Reg (Il.next_vreg cx.ctxt_emit) in 
            begin
		      emit Il.ADD tmp av bv;
              tmp
            end
      | Ast.RES_member (layout, lv) -> 
          begin
            match trans_resolved_path cx lv with
                Il.Mem (m, v, Asm.IMM off') -> 
                  Il.Mem (m, v, Asm.IMM (Int64.add layout.layout_offset off'))
              | v -> 
                  let tmp = Il.Reg (Il.next_vreg cx.ctxt_emit) in
                    emit Il.ADD tmp v (Il.Imm (Asm.IMM layout.layout_offset));
                    tmp
          end
      | Ast.RES_deref lv -> 
          begin
            match trans_resolved_path cx lv with 
                Il.Reg r -> 
                  Il.Mem (cx.ctxt_abi.Abi.abi_ptr_mem, Some r, Asm.IMM 0L)
              | v -> 
		          let tmp = (Il.next_vreg cx.ctxt_emit) in 
		            emit Il.MOV (Il.Reg tmp) v Il.Nil;
                    Il.Mem (cx.ctxt_abi.Abi.abi_ptr_mem, Some tmp, Asm.IMM 0L)
          end
;;

(* FIXME: the analysis here has to be a fair bit deeper. The thing to
 * do at minimum (I think; it's ill-discussed in "introductory" texts)
 * is to work out, during resolve phase, which slots are "purely local"
 * -- that is, never aliased -- and mark them as such in the frame,
 * then layout the frame only covering the possibly-aliased slots, and
 * always translate them using Mem operands. The "purely local" ones
 * can be vregs, as below here, and if they spill they get tacked on to
 * the auxiliary portion of the frame generated by RA, not the
 * "official" frame full of the aliased parts.
 * 
 * For now the existing heuristic is probably OK because neither
 * call-by-alias, environment capture, not nothing else that could be a
 * threat to the logic is implemented!  
 *)

let trans_lval_full
    (cx:ctxt) 
    (lv:Ast.lval)
    (pcrel_ok:bool)
    (imm_ok:bool)
    : Il.operand = 
  match !(lv.Ast.lval_res) with 
      None -> raise (Semant_err (Some lv.Ast.lval_src.span, 
                                 "unresolved lval in trans_lval"))
    | Some res -> 
        match res.Ast.res_target with 
            Ast.RES_item ri -> 
              begin
                match ri.node with 
                    (Ast.MOD_ITEM_fn fd) -> 
                      let fix = fd.Ast.decl_item.Ast.fn_fixup in
                      if pcrel_ok
                      then Il.Pcrel fix
                      else 
                        let imm = (Il.Imm (Asm.M_POS fix)) in 
                          if imm_ok 
                          then imm
                          else 
                            let tmp = (Il.next_vreg cx.ctxt_emit) in 
		                      Il.emit cx.ctxt_emit Il.MOV (Il.Reg tmp) imm Il.Nil;
                              (Il.Reg tmp)
                  | _ -> raise (Semant_err (Some lv.Ast.lval_src.span, 
                                            "unhandled form of mod item in trans_lval"))
              end
          | Ast.RES_slot local -> 
              begin 
                match res.Ast.res_path with 
                    (Ast.RES_member (layout, (Ast.RES_deref (Ast.RES_pr FP))))
                       when (Int64.compare layout.layout_offset cx.ctxt_abi.Abi.abi_frame_base) >= 0 -> 
                         begin
                          (* In this case, we're translating a local. We'll assign a vreg. *)
                          (* FIXME: only do this if the local is subword-sized. *)
                          let cell = local.Ast.local_vreg in 
                            match !cell with 
                                Some v -> Il.Reg (Il.Vreg v)
                              | None -> 
                                  let vr = (Il.next_vreg cx.ctxt_emit) in
                                    begin
                                      match vr with 
                                          Il.Vreg v -> cell := Some v
                                        | _ -> failwith "non-vreg in Trans.trans_lval"
                                    end;
                                    Il.Reg vr
                        end
                  | pth -> 
                      let rec rp_str p = 
                        match p with 
                            Ast.RES_pr FP -> "FP"
                          | Ast.RES_pr PP -> "PP"
                          | Ast.RES_pr CP -> "CP"
                          | Ast.RES_pr RP -> "RP"
                          | Ast.RES_idx (a, b) -> 
                              Printf.sprintf "RES_idx(%s,%s)" (rp_str a) (rp_str b)
                          | Ast.RES_member (layout, lv) -> 
                              Printf.sprintf "RES_member(%Ld,%s)" layout.layout_offset (rp_str lv)
                          | Ast.RES_deref lv -> 
                              Printf.sprintf "RES_deref(%s)" (rp_str lv)                                
                      in
                      let nbstr nb = 
                        match nb with 
	                        (Ast.BASE_ident id) -> id
	                      | (Ast.BASE_temp n) -> "<temp#" ^ (string_of_int n) ^ ">"
	                      | (Ast.BASE_app (id, tys)) -> "[...]"
                      in
                      let lvstr = 
                        match lv.Ast.lval_src.node with 
                            Ast.LVAL_base nbase -> nbstr nbase
                          | _ -> "??"
                      in                        
                        log cx "translating lval path for %s: %s" lvstr (rp_str pth); 
                        trans_resolved_path cx pth
              end
;;


let trans_lval
    (cx:ctxt) 
    (lv:Ast.lval)
    : Il.operand = 
  trans_lval_full cx lv false false
;;


let trans_atom 
    (cx:ctxt) 
    (atom:Ast.atom)
    : Il.operand = 
  match atom with 
    | Ast.ATOM_lval lv -> 
        trans_lval cx lv
          
	| Ast.ATOM_literal lit -> 
        begin 
          match lit.node with 
              Ast.LIT_nil -> 
		        Il.Nil
                  
	        | Ast.LIT_bool false -> 
		        Il.Imm (Asm.IMM 0L)
          
	        | Ast.LIT_bool true -> 
		        Il.Imm (Asm.IMM 1L)
          
	        | Ast.LIT_char c -> 
		        Il.Imm (Asm.IMM (Int64.of_int (Char.code c)))
          
	        | Ast.LIT_int (bi, s) -> 
		        Il.Imm (Asm.IMM (Int64.of_int (Big_int.int_of_big_int bi)))
                  
	        | _ -> marker (* raise  (Invalid_argument "Trans.trans_atom: unimplemented translation") *)
        end
        

let trans_expr 
    (cx:ctxt) 
    (expr:Ast.expr)
    : Il.operand = 
  let emit = Il.emit cx.ctxt_emit in
    match expr with 
        
	    Ast.EXPR_binary (binop, a, b) -> 
	      let lhs = trans_atom cx a in
		  let rhs = trans_atom cx b in
		  let dst = Il.Reg (Il.next_vreg cx.ctxt_emit) in 
          let arith op = 
			emit op dst lhs rhs;
			dst
          in
          let rela cjmp = 
            emit Il.CMP Il.Nil lhs rhs;
            emit Il.MOV dst imm_true Il.Nil;
            let j = mark cx in
              emit cjmp badlab Il.Nil Il.Nil;
              emit Il.MOV dst imm_false Il.Nil;
              patch cx j;
              dst
          in
            begin 
		      match binop with
                  Ast.BINOP_or -> arith Il.OR
                | Ast.BINOP_and -> arith Il.AND
                    
                | Ast.BINOP_lsl -> arith Il.LSL
                | Ast.BINOP_lsr -> arith Il.LSR
                | Ast.BINOP_asr -> arith Il.ASR
                    
                | Ast.BINOP_add -> arith Il.ADD
                | Ast.BINOP_sub -> arith Il.SUB
                    
                (* FIXME: switch on type of operands. *)
                | Ast.BINOP_mul -> arith Il.UMUL
                | Ast.BINOP_div -> arith Il.UDIV
                | Ast.BINOP_mod -> arith Il.UMOD
                    
                | Ast.BINOP_eq -> rela Il.JE                
                | Ast.BINOP_ne -> rela Il.JNE                
                | Ast.BINOP_lt -> rela Il.JL
                | Ast.BINOP_le -> rela Il.JLE
                | Ast.BINOP_ge -> rela Il.JGE
                | Ast.BINOP_gt -> rela Il.JG
                    
			    | _ -> raise (Invalid_argument "Trans.trans_expr: unimplemented binop")
            end

	  | Ast.EXPR_unary (unop, a) -> 
		  let src = trans_atom cx a in
		  let dst = Il.Reg (Il.next_vreg cx.ctxt_emit) in 
		  let op = match unop with
			  Ast.UNOP_not -> Il.NOT
			| Ast.UNOP_neg -> Il.NEG
		  in
			emit op dst src Il.Nil;
			dst

      | Ast.EXPR_atom a -> 
          trans_atom cx a
              
	  | _ -> raise (Invalid_argument "Trans.trans_expr: unimplemented translation")
;;


let rec trans_stmt 
    (cx:ctxt) 
    (stmt:Ast.stmt)
    : unit =
  let emit = Il.emit cx.ctxt_emit in
    match stmt.node with 
	    Ast.STMT_copy (lv_dst, e_src) -> 
		  let dst = trans_lval cx lv_dst in
		  let src = trans_expr cx e_src in
		    emit Il.MOV dst src Il.Nil
              
	  | Ast.STMT_block stmts -> 
		  Array.iter (trans_stmt cx) stmts.Ast.block_stmts
          
      | Ast.STMT_while sw -> 
          let back_jmp_target = mark cx in 
          let (head_stmts, head_atom) = sw.Ast.while_lval in
		    Array.iter (trans_stmt cx) head_stmts;
            let v = trans_atom cx head_atom in
              emit Il.CMP Il.Nil v imm_false;
              let fwd_jmp_quad = mark cx in
                emit Il.JE badlab Il.Nil Il.Nil;
                trans_stmt cx sw.Ast.while_body;
                emit Il.JMP (Il.Label back_jmp_target) Il.Nil Il.Nil;
                patch cx fwd_jmp_quad
                  
      | Ast.STMT_if si -> 
          let v = trans_atom cx si.Ast.if_test in 
            emit Il.CMP Il.Nil v imm_true;
            let skip_thn_clause_jmp = mark cx in 
              emit Il.JE badlab Il.Nil Il.Nil;
              trans_stmt cx si.Ast.if_then;
              begin 
                match si.Ast.if_else with 
                    None -> patch cx skip_thn_clause_jmp
                  | Some els -> 
                      let skip_els_clause_jmp = mark cx in
                        emit Il.JE badlab Il.Nil Il.Nil;
                        patch cx skip_thn_clause_jmp;
                        trans_stmt cx els;
                        patch cx skip_els_clause_jmp                        
              end

      | Ast.STMT_call (dst, fn, args) -> 
          let abi = cx.ctxt_abi in
            (* FIXME: factor out call protocol into ABI bits. *)
            for i = 0 to (Array.length args) - 1 do              
              emit (Il.CPUSH Il.M32) Il.Nil (trans_atom cx args.(i)) Il.Nil
            done;
            let vr = Il.Reg (Il.next_vreg cx.ctxt_emit) in 
            let dst = trans_lval cx dst in
            let fn = (trans_lval_full cx fn abi.Abi.abi_has_pcrel_jumps abi.Abi.abi_has_imm_jumps) in
            emit Il.CCALL vr fn Il.Nil;
            emit Il.MOV dst vr Il.Nil;
            emit Il.ADD abi.Abi.abi_sp_operand abi.Abi.abi_sp_operand 
              (Il.Imm (Asm.IMM (Int64.of_int (4 * (Array.length args)))));

      | _ -> ()
                
(* 

    | Ast.STMT_do_while sw ->
  | STMT_foreach of stmt_foreach
  | STMT_for of stmt_for
  | STMT_try of stmt_try
  | STMT_put of (proto option * lval option)
  | STMT_ret of (proto option * lval option)
  | STMT_be of (proto option * lval * (lval array))
  | STMT_alt_tag of stmt_alt_tag
  | STMT_alt_type of stmt_alt_type
  | STMT_alt_port of stmt_alt_port
  | STMT_prove of (constrs)
  | STMT_check of (constrs)
  | STMT_checkif of (constrs * stmt)
  | STMT_send of (lval * lval)
  | STMT_recv of (lval * lval)
  | STMT_decl of stmt_decl 
  | STMT_use of (ty * ident * lval)
	| _ -> raise (Invalid_argument "Semant.trans_stmt: unimplemented translation")
*)

and trans_fn (cx:ctxt) (fn:Ast.fn) : unit =
  let _ = reset_emitter cx in
  let emit = Il.emit cx.ctxt_emit in  
  let r x = Il.Reg (Il.Hreg x) in
    (* FIXME: factor out prologue / epilogue into ABI bits. *)
    Il.emit_full cx.ctxt_emit (Some fn.Ast.fn_fixup) Il.MOV (r X86.ebp) (r X86.esp) Il.Nil;
    emit Il.SUB (r X86.esp) (r X86.esp) (Il.Imm (Asm.IMM fn.Ast.fn_frame.Ast.frame_layout.layout_size));
    trans_stmt cx fn.Ast.fn_body;
    emit Il.MOV (r X86.esp) (r X86.ebp) Il.Nil;
    Il.emit cx.ctxt_emit Il.CRET Il.Nil Il.Nil Il.Nil;
    capture_emitted_quads cx

      
and trans_prog (cx:ctxt) (p:Ast.prog) : unit = 
  trans_mod_items cx p.Ast.prog_mod


and trans_mod_item 
    (cx:ctxt) 
    (name:Ast.ident) 
    (item:Ast.mod_item) 
    : unit = 
  let oldpath = cx.ctxt_path in 
    cx.ctxt_path <- name :: cx.ctxt_path;
    begin
      match item.node with 
	      Ast.MOD_ITEM_fn f -> trans_fn cx f.Ast.decl_item
	    | Ast.MOD_ITEM_mod m -> trans_mod_items cx m.Ast.decl_item
	    | Ast.MOD_ITEM_prog p -> trans_prog cx p.Ast.decl_item
	    | _ -> ()
    end;
    cx.ctxt_path <- oldpath
            

and trans_mod_items 
    (cx:ctxt) 
    (items:Ast.mod_items)
    : unit = 
  Hashtbl.iter (trans_mod_item cx) items

    
and trans_crate 
    (sess:Session.sess)
    (abi:Abi.abi)
    (crate:Ast.mod_items) 
    : ((string, (Il.quads * int)) Hashtbl.t * Asm.item list) = 
  try
    let cx = new_ctxt sess abi in 
	  trans_mod_items cx crate;
      (cx.ctxt_text_items, cx.ctxt_data_items)
  with 
	  Semant_err (spano, str) -> 
        begin
		  match spano with 
			  None -> 
                Session.fail sess "Trans error: %s\n%!" str
		    | Some span -> 			  
			    Session.fail sess "%s:E:Trans error: %s\n%!" 
                  (Session.string_of_span span) str
        end;
        (Hashtbl.create 0, [])
;;

(* 
 * Local Variables:
 * fill-column: 70; 
 * indent-tabs-mode: nil
 * compile-command: "make -k -C .. 2>&1 | sed -e 's/\\/x\\//x:\\//g'"; 
 * End:
 *)
