(* Translation *)

open Semant;;
open Common;;

type ctxt = 
    {
      ctxt_emit: Il.emitter;
      ctxt_sess: Session.sess;
      ctxt_abi: Abi.abi;
    }

let new_ctxt (sess:Session.sess) (abi:Abi.abi) : ctxt = 
  { 
    ctxt_emit = Il.new_emitter ();
    ctxt_sess = sess;
    ctxt_abi = abi
  }


let marker = Il.Imm (Asm.IMM 0xdeadbeefL);;
let imm_true = Il.Imm (Asm.IMM 1L);;
let imm_false = Il.Imm (Asm.IMM 0L);;
let badlab = Il.Label (-1);;

let mark (cx:ctxt) : int = 
  cx.ctxt_emit.Il.emit_pc
;;

let patch (cx:ctxt) (i:int) : unit = 
  cx.ctxt_emit.Il.emit_quads.(i) 
  <- { cx.ctxt_emit.Il.emit_quads.(i)
       with Il.quad_dst = Il.Label (mark cx) }
;;  

let log cx = Session.log "trans" 
  cx.ctxt_sess.Session.sess_log_trans
  cx.ctxt_sess.Session.sess_log_out
;;

let rec trans_resolved_path 
    (cx:ctxt) 
    (resp:Ast.resolved_path) = 
  let emit = Il.emit cx.ctxt_emit in  
    match resp with 
        Ast.RES_pr FP -> cx.ctxt_abi.Abi.abi_fp_operand
      | Ast.RES_pr PP -> cx.ctxt_abi.Abi.abi_pp_operand
      | Ast.RES_pr CP -> cx.ctxt_abi.Abi.abi_cp_operand
      | Ast.RES_pr RP -> cx.ctxt_abi.Abi.abi_rp_operand
      | Ast.RES_idx (a, b) -> 
          let av = trans_resolved_path cx a in
          let bv = trans_resolved_path cx b in          
		  let tmp = Il.Reg (Il.next_vreg cx.ctxt_emit) in 
            begin
		      emit Il.ADD tmp av bv;
              tmp
            end
      | Ast.RES_off (off, lv) -> 
          begin
            match trans_resolved_path cx lv with
                Il.Mem (m, v, Asm.IMM off') -> 
                  Il.Mem (m, v, Asm.IMM (Int64.add off off'))
              | v -> 
                  let tmp = Il.Reg (Il.next_vreg cx.ctxt_emit) in
                    emit Il.ADD tmp v (Il.Imm (Asm.IMM off));
                    tmp
          end
      | Ast.RES_deref lv -> 
          begin
            match trans_resolved_path cx lv with 
                Il.Reg r -> 
                  Il.Mem (cx.ctxt_abi.Abi.abi_ptr_mem, Some r, Asm.IMM 0L)
              | v -> 
		          let tmp = (Il.next_vreg cx.ctxt_emit) in 
		            emit Il.MOV (Il.Reg tmp) v Il.Nil;
                    Il.Mem (cx.ctxt_abi.Abi.abi_ptr_mem, Some tmp, Asm.IMM 0L)
          end
;;

(* FIXME: the analysis here has to be a fair bit deeper. The thing to
 * do at minimum (I think; it's ill-discussed in "introductory" texts)
 * is to work out, during resolve phase, which slots are "purely local"
 * -- that is, never aliased -- and mark them as such in the frame,
 * then layout the frame only covering the possibly-aliased slots, and
 * always translate them using Mem operands. The "purely local" ones
 * can be vregs, as below here, and if they spill they get tacked on to
 * the auxiliary portion of the frame generated by RA, not the
 * "official" frame full of the aliased parts.
 * 
 * For now the existing heuristic is probably OK because neither
 * call-by-alias, environment capture, not nothing else that could be a
 * threat to the logic is implemented!  
 *)

let trans_lval 
    (cx:ctxt) 
    (lv:Ast.lval)
    : Il.operand = 
  match !(lv.Ast.lval_res) with 
      None -> raise (Semant_err (Some lv.Ast.lval_src.span, 
                                 "unresolved lval in trans_lval"))
    | Some res -> 
        begin 
          match res.Ast.res_path with 
              (Ast.RES_off (n, (Ast.RES_deref (Ast.RES_pr FP)))) when n != 0L -> 
                begin
                  (* In this case, we're translating a local. We'll assign a vreg. *)
                  (* FIXME: only do this if the local is subword-sized. *)
                  let cell = lv.Ast.lval_vreg in 
                    match !cell with 
                        Some v -> Il.Reg (Il.Vreg v)
                      | None -> 
                          let vr = (Il.next_vreg cx.ctxt_emit) in
                            begin
                              match vr with 
                                  Il.Vreg v -> cell := Some v
                                | _ -> failwith "non-vreg in Trans.trans_lval"
                            end;
                            Il.Reg vr
                end
            | pth -> trans_resolved_path cx pth
        end
;;

let trans_atom 
    (cx:ctxt) 
    (atom:Ast.atom)
    : Il.operand = 
  match atom with 
    | Ast.ATOM_lval lv -> 
        trans_lval cx lv
          
	| Ast.ATOM_literal lit -> 
        begin 
          match lit.node with 
              Ast.LIT_nil -> 
		        Il.Nil
                  
	        | Ast.LIT_bool false -> 
		        Il.Imm (Asm.IMM 0L)
          
	        | Ast.LIT_bool true -> 
		        Il.Imm (Asm.IMM 1L)
          
	        | Ast.LIT_char c -> 
		        Il.Imm (Asm.IMM (Int64.of_int (Char.code c)))
          
	        | Ast.LIT_int (bi, s) -> 
		        Il.Imm (Asm.IMM (Int64.of_int (Big_int.int_of_big_int bi)))
                  
	        | _ -> marker (* raise  (Invalid_argument "Trans.trans_atom: unimplemented translation") *)
        end
        

let trans_expr 
    (cx:ctxt) 
    (expr:Ast.expr)
    : Il.operand = 
  let emit = Il.emit cx.ctxt_emit in
    match expr with 
        
	    Ast.EXPR_binary (binop, a, b) -> 
	      let lhs = trans_atom cx a in
		  let rhs = trans_atom cx b in
		  let dst = Il.Reg (Il.next_vreg cx.ctxt_emit) in 
          let arith op = 
            if cx.ctxt_abi.Abi.abi_is_2addr_machine
            then 
			  (emit Il.MOV dst lhs Il.Nil;
               emit op dst dst rhs)
            else
			  emit op dst lhs rhs;
			dst
          in
          let rela cjmp = 
            if cx.ctxt_abi.Abi.abi_is_2addr_machine
            then 
              begin
                let t = Il.Reg (Il.next_vreg cx.ctxt_emit) in
                  emit Il.MOV t lhs Il.Nil;
                  emit Il.CMP Il.Nil t rhs
              end
            else 
              emit Il.CMP Il.Nil lhs rhs;
            emit Il.MOV dst imm_true Il.Nil;
            let j = mark cx in
              emit cjmp badlab Il.Nil Il.Nil;
              emit Il.MOV dst imm_false Il.Nil;
              patch cx j;
              dst
          in
            begin 
		      match binop with
                  Ast.BINOP_or -> arith Il.OR
                | Ast.BINOP_and -> arith Il.AND
                    
                | Ast.BINOP_lsl -> arith Il.LSL
                | Ast.BINOP_lsr -> arith Il.LSR
                | Ast.BINOP_asr -> arith Il.ASR
                    
                | Ast.BINOP_add -> arith Il.ADD
                | Ast.BINOP_sub -> arith Il.SUB
                    
                (* FIXME: switch on type of operands. *)
                (* FIXME: wire to reg X86.eax, sigh.  *)
                (* 
                   | Ast.BINOP_mul -> Il.UMUL
                   | Ast.BINOP_div -> Il.UDIV
                   | Ast.BINOP_mod -> Il.UMOD
                *)
                    
                | Ast.BINOP_eq -> rela Il.JE                
                | Ast.BINOP_ne -> rela Il.JNE                
                | Ast.BINOP_lt -> rela Il.JL
                | Ast.BINOP_le -> rela Il.JLE
                | Ast.BINOP_ge -> rela Il.JGE
                | Ast.BINOP_gt -> rela Il.JG
                    
			    | _ -> raise (Invalid_argument "Trans.trans_expr: unimplemented binop")
            end

	  | Ast.EXPR_unary (unop, a) -> 
		  let src = trans_atom cx a in
		  let dst = Il.Reg (Il.next_vreg cx.ctxt_emit) in 
		  let op = match unop with
			  Ast.UNOP_not -> Il.NOT
			| Ast.UNOP_neg -> Il.NEG
		  in
            if cx.ctxt_abi.Abi.abi_is_2addr_machine
            then 
			  (emit Il.MOV dst src Il.Nil;
               emit op dst dst Il.Nil)
            else               
			  emit op dst src Il.Nil;
			dst

      | Ast.EXPR_atom a -> 
          trans_atom cx a
              
	  | _ -> raise (Invalid_argument "Trans.trans_expr: unimplemented translation")
;;


let rec trans_stmt 
    (cx:ctxt) 
    (stmt:Ast.stmt)
    : unit =
  let emit = Il.emit cx.ctxt_emit in
    match stmt.node with 
	    Ast.STMT_copy (lv_dst, e_src) -> 
		  let dst = trans_lval cx lv_dst in
		  let src = trans_expr cx e_src in
		    emit Il.MOV dst src Il.Nil
              
	  | Ast.STMT_block stmts -> 
		  Array.iter (trans_stmt cx) stmts.Ast.block_stmts
          
      | Ast.STMT_while sw -> 
          let back_jmp_target = mark cx in 
          let (head_stmts, head_atom) = sw.Ast.while_lval in
		    Array.iter (trans_stmt cx) head_stmts;
            let v = trans_atom cx head_atom in
              emit Il.CMP Il.Nil v imm_false;
              let fwd_jmp_quad = mark cx in
                emit Il.JE badlab Il.Nil Il.Nil;
                trans_stmt cx sw.Ast.while_body;
                emit Il.JMP (Il.Label back_jmp_target) Il.Nil Il.Nil;
                patch cx fwd_jmp_quad
                  
      | Ast.STMT_if si -> 
          let v = trans_atom cx si.Ast.if_test in 
            emit Il.CMP Il.Nil v imm_true;
            let skip_thn_clause_jmp = mark cx in 
              emit Il.JE badlab Il.Nil Il.Nil;
              trans_stmt cx si.Ast.if_then;
              begin 
                match si.Ast.if_else with 
                    None -> patch cx skip_thn_clause_jmp
                  | Some els -> 
                      let skip_els_clause_jmp = mark cx in
                        emit Il.JE badlab Il.Nil Il.Nil;
                        patch cx skip_thn_clause_jmp;
                        trans_stmt cx els;
                        patch cx skip_els_clause_jmp                        
              end

      | _ -> ()
                
(* 

    | Ast.STMT_do_while sw ->
  | STMT_foreach of stmt_foreach
  | STMT_for of stmt_for
  | STMT_try of stmt_try
  | STMT_put of (proto option * lval option)
  | STMT_ret of (proto option * lval option)
  | STMT_be of (proto option * lval * (lval array))
  | STMT_alt_tag of stmt_alt_tag
  | STMT_alt_type of stmt_alt_type
  | STMT_alt_port of stmt_alt_port
  | STMT_prove of (constrs)
  | STMT_check of (constrs)
  | STMT_checkif of (constrs * stmt)
  | STMT_call of (lval * lval * (lval array))
  | STMT_send of (lval * lval)
  | STMT_recv of (lval * lval)
  | STMT_decl of stmt_decl 
  | STMT_use of (ty * ident * lval)
	| _ -> raise (Invalid_argument "Semant.trans_stmt: unimplemented translation")
*)

and trans_fn (cx:ctxt) (fn:Ast.fn) : unit = 
  trans_stmt cx fn.Ast.fn_body

and trans_prog (cx:ctxt) (p:Ast.prog) : unit = 
  trans_mod_items cx p.Ast.prog_mod

and trans_mod_item 
    (cx:ctxt) 
    (name:Ast.ident) 
    (item:Ast.mod_item) 
    : unit = 
  match item.node with 
	  Ast.MOD_ITEM_fn f -> trans_fn cx f.Ast.decl_item
	| Ast.MOD_ITEM_mod m -> trans_mod_items cx m.Ast.decl_item
	| Ast.MOD_ITEM_prog p -> trans_prog cx p.Ast.decl_item
	| _ -> ()
 

and trans_mod_items 
    (cx:ctxt) 
    (items:Ast.mod_items)
    : unit = 
  Hashtbl.iter (trans_mod_item cx) items
    
and trans_crate 
    (sess:Session.sess)
    (abi:Abi.abi)
    (crate:Ast.mod_items) 
    : (Il.quads * int) = 
  try
    let cx = new_ctxt sess abi in 
	  trans_mod_items cx crate;
      let quads = cx.ctxt_emit.Il.emit_quads in
        begin
          log cx "emitted quads:";
          for i = 0 to (Array.length quads) - 1
          do 
            log cx "[%6d]\t%s" i (Il.string_of_quad quads.(i));
          done
        end;        
        (quads, cx.ctxt_emit.Il.emit_next_vreg)
          
  with 
	  Semant_err (spano, str) -> 
        begin
		  match spano with 
			  None -> 
                Session.fail sess "Trans error: %s\n%!" str
		    | Some span -> 			  
			    Session.fail sess "%s:E:Trans error: %s\n%!" 
                  (Session.string_of_span span) str
        end;
        ([| |], 0)
;;

(* 
 * Local Variables:
 * fill-column: 70; 
 * indent-tabs-mode: nil
 * compile-command: "make -k -C .. 2>&1 | sed -e 's/\\/x\\//x:\\//g'"; 
 * End:
 *)
